Как обратиться к предкам.

Множественное наследование порождает ещё одну специфическую проблему. На самом деле непосредственный поиск какого-то метода в родительских классах — это лишь часть пользы, которую можно извлечь из него. Как и в случае одиночного наследования, часто можно облегчить себе жизнь, реализовав в потомке метод, который помимо некоторых действий будет вызывать тот же самый метод родителя. Например, достаточно часто можно встретить такое:
class B(A):
    def __init__(self):
        # something
        A.__init__(self)

Однако, для случая множественного наследования этот подход не годится. И вот по каким причинам:
class C(B, A):
    def __init__(self):
        # something
        B.__init__(self)
        A.__init__(self)

Во-первых, мы явно обращаемся к родительским классам (вообще-то и в примере с одиночным наследованием то же самое). Если мы захотим заменить кого-то из предков на другой класс или вообще убрать, то нам придётся изменять все функции, которые к нему обращались. Это чревато багами, если мы что-нибудь пропустим. Но это ещё пол беды. Во-вторых, мы ничего не знаем о классах A и B. Возможно, у них есть общие предки, к которым они обращаются аналогичным образом:
class A(P1, P2):
    def __init__(self):
        # something
        P1.__init__(self)
        P2.__init__(self)

class B(P1, P2):
    def __init__(self):
        # something
        P1.__init__(self)
        P2.__init__(self)

Если это так, то получится, что инициализация общих предков отработает два раза. Это не правильно. Чтобы этого избежать в Питоне есть класс super. В версии 3.0 он окончательно очеловечен и к нему можно обращаться следующим образом:
class C(B, A):
    def __init__(self):
        # something
        super().__init__() # для версий младше 3.0 нужно использовать super(C, self)