<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="ru" xml:lang="ru">
<head>
  <title>XMLHTTPRequest: описание, применение, частые проблемы | XmlHttpRequest.ru</title>
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" href="/misc/favicon.ico" type="image/x-icon" />
  <style type="text/css" media="all">@import "/files/css/f55660afceaf275a5e141bf10206b993.css";</style>
  <script type="text/javascript" src="/misc/jquery.js"></script>
<script type="text/javascript" src="/misc/drupal.js"></script>
<script type="text/javascript" src="/modules/codeviewer/codeviewer.js"></script>
<script type="text/javascript">Drupal.extend({ settings: { "googleanalytics": { "trackDownload": "pdf|zip|mp3" } } });</script>
</head>

<body bgcolor="#ffffff">

<div class="hide"><a href="#content" title="Пропустить навигацию." accesskey="2">Пропустить навигацию</a>.</div>

<table id="primary-menu" summary="Navigation elements." border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td id="home" width="10%">
              <a href="/" title="Главная"><img src="/themes/pushbutton/logo.png" alt="Главная" border="0" /></a>
          </td>

    <td id="site-info" width="20%">
              <div class='site-name'><a href="/" title="Главная">XmlHttpRequest.ru</a></div>
                </td>
    <td class="primary-links" width="70%" align="center" valign="middle">
      <ul class="links" id="navlist"><li class="first menu-1-1-2"><a href="http://xmlhttprequest.ru" class="menu-1-1-2">Главная</a></li>
<li class="menu-1-2-2"><a href="/w3c" class="menu-1-2-2">Спецификация W3C</a></li>
<li class="menu-1-3-2"><a href="http://forum.javascript.ru" class="menu-1-3-2">Форум</a></li>
<li class="last menu-1-4-2"><a href="http://javascript.ru" class="menu-1-4-2">Другие статьи по javascript</a></li>
</ul>    </td>
  </tr>
</table>

<table id="secondary-menu" summary="Navigation elements." border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td class="secondary-links" width="75%"  align="center" valign="middle">
          </td>
    <td  width="25%"  align="center" valign="middle">
          </td>
  </tr>
  <tr>
    <td colspan="2"><div></div></td>
  </tr>
</table>

<table id="content" border="0" cellpadding="15" cellspacing="0" width="100%">
  <tr>
    
    <td valign="top">
      
      <div id="main">
                            <h1 class="title">XMLHTTPRequest: описание, применение, частые проблемы</h1>

          
        
        
        
      <!-- start main content -->
      <div class="node">
        <span class="submitted">Опубликовано <a href="/user/1" title="Информация о пользователе.">admin</a> в 19.12.2007 в 13:43.</span>
    <span class="taxonomy"></span>
    <div class="content"><style>
#footer-div {
        text-align:center;font-size:large;
        margin: 20px;
}
#footer-div a {
 margin: 10px;     
}
code { font-size: 1.2em }
</style>
<script type="text/javascript" src="/xhr.js"></script>
<a name="top"></a>

<p>Здесь Вы найдете полное описание объекта XMLHTTPRequest, способы использования, форматы данных и разбор частых проблем. На отдельной страничке - <a href="/w3c">спецификация объекта XMLHTTPRequest</a>, согласно W3C.</p>

<p>Полезного чтения.</p>


<ul>
<li><a href="#start">Введение</a></li>
<li><a href="#use">Использование XMLHTTPRequest</a></li>
<li><a href="#method">Методы объекта XMLHTTPRequest</a></li>
<li><a href="#props">Использование XMLHTTPRequest</a></li>
<li><a href="#encoding">GET и POST-запросы. <i>Кодировка</i></a></li>
<li><a href="#problem">Частые проблемы</a></li>
<li><a href="#security">Ограничения безопасности. Кросс-доменный XMLHTTPRequest</a></li>
<li><a href="#frameworks">Поддержка в библиотеках</a></li>
</ul>


<hr/>

    <h1 id="start">Объект XMLHttpRequest</h1>


    <p>
   Объект XMLHttpRequest (или, сокращенно, XHR) дает возможность браузеру делать HTTP-запросы к серверу без перезагрузки страницы.
</p>

    <p>
    Несмотря на слово XML в названии, XMLHttpRequest может работать с данными в любом текстовом формате, и даже c бинарными данными. Использовать его очень просто.
    </p>

    <h2>Кроссбраузерное создание объекта запроса</h2>

    <p>В зависимости от браузера, код для создания объекта может быть разный.<br/> Кроссбраузерная функция создания XMLHttpRequest:</p>
<pre>
function getXmlHttp(){
  var xmlhttp;
  try {
    xmlhttp = new ActiveXObject("Msxml2.XMLHTTP");
  } catch (e) {
    try {
      xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
    } catch (E) {
      xmlhttp = false;
    }
  }
  if (!xmlhttp &amp;&amp; typeof XMLHttpRequest!='undefined') {
    xmlhttp = new XMLHttpRequest();
  }
  return xmlhttp;
}
</pre>
    Функция тупо перебирает возможные внутренние реализации и возвращает начальный объект XMLHttpRequest. Существует и масса других рабочих кроссбраузерных функций, однако все они по сути делают то же самое.

<a name="use"></a>
    <h2>Использование XMLHTTPRequest</h3>

<p>Различают два использования XmlHttpRequest. Первое - самое простое, синхронное.</p>

<h3>Синхронный XMLHttpRequest</h3>

В этом примере через XMLHTTPRequest с сервера запрашивается страница http://example.org/, и текст ответа сервера показывается через alert().
<pre>
var xmlhttp = getXmlHttp()
xmlhttp.open('GET', '/xhr/test.html', false);
xmlhttp.send(null);
if(xmlhttp.status == 200) {
  alert(xmlhttp.responseText);
}
</pre>

<p>Здесь сначала создается запрос, задается открытие (<a href="#method_open">open</a>) синхронного соединение с адресом /xhr/test.html и запрос отсылается с null,
 т.е без данных: <a href="#method_send">send(null)</a>.</p>
<p>
<u>При синхронном запросе браузер "подвисает" и ждет на строчке 3, пока сервер не ответит на запрос.</u> Когда ответ получен - выполняется строка 4, код ответа сравнивается с 200 (ОК), и при помощи alert
печатается текст ответа сервера. Все максимально просто.</p>

<p>Свойство responseText получит такой же текст страницы, как браузер, если бы Вы в перешли на /xhr/test.html. Для сервера
GET-запрос через XmlHttpRequest ничем не отличается от обычного перехода на страницу.
</p>

<input type="button" value="Запустить синхронный пример (ответ от сервера будет через 3 секунды, браузер подвиснет)" onclick="example1()"/>


<h3>Асинхронный XMLHttpRequest</h3>

Этот пример делает то же самое, но асинхронно, т.е браузер не ждет выполнения запроса для продолжения скрипта. Вместо этого к свойству onreadystatechange подвешивается
функция, которую запрос вызовет сам, когда получит ответ с сервера.

<pre>
var xmlhttp = getXmlHttp()
xmlhttp.open('GET', '/xhr/test.html', <b>true</b>);
xmlhttp.onreadystatechange = function() {
  if (xmlhttp.readyState == 4) {
     if(xmlhttp.status == 200) {
       alert(xmlhttp.responseText);
         }
  }
};
xmlhttp.send(null);
</pre>

<p>Асинхронность включается третьим параметром функции open. В отличие от синхронного запроса, функция send() не останавливает
выполнение скрипта, а просто отправляет запрос.</p>

<input type="button" value="Запустить асинхронный пример (браузер не подвиснет, а сделает запрос прозрачно 'за кадром')" onclick="example2()"/>

<p>Запрос xmlhttp регулярно отчитывается о своем состоянии через вызов функции xmlhttp.onreadystatechange. Состояние под номером 4 означает конец выполнения, поэтому функция-обработчик
при каждом вызове проверяет - не настало ли это состояние.</p>

<p>
Вообще, список состояний readyState такой:
</p>

<ul>
<li>0 - <em>Unitialized</em></li>
<li>1 - <em>Loading</em></li>
<li>2 - <em>Loaded</em></li>
<li>3 - <em>Interactive</em></li>
<li>4 - <em>Complete</em></li>
</ul>

<p>Состояния 0-2 вообще не используются.</p>

<p>Вызов функции с состоянием <em>Interactive</em> в теории должен происходить каждый раз при получении очередной порции данных от сервера.
 Это могло бы быть удобным для обработки ответа по частям, но Internet Explorer не дает доступа к уже полученной части ответа. <br/>
 Firefox дает такой доступ, но для обработки запроса по частям состояние <em>Interactive</em> все равно неудобно из-за сложностей обнаружения ошибок соединения.
 Поэтому <em>Interactive</em> тоже не используется.</p>

<p>На практике используется только последнее, <em>Complete</em>.</p>

<p>Если хотите углубиться в тонкости багов браузеров c readyState, отличными от 4, то многие из них рассмотрены в статье на
<a href="http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_r_2.html">Quirksmode (англ.)</a>.</p>

 <h3>Не используйте синхронные запросы</h3>

 <p>Синхронные запросы применяются только в крайнем случае, когда кровь из носу необходимо дождаться ответа сервера до продолжения скрипта. В 999 случаях из 1000
 можно использовать асинхронные запросы. При этом общий алгоритм такой:</p>

 <ol>
 <li>Делаем асинхронный запрос</li>
 <li>Рисуем анимированную картинку или просто запись типа "Loading..."
 <li>В onreadystatechange при достижении состояния 4 убираем Loading и, в зависимости от status вызываем обработку ответа или ошибки.</li>
 </ol>

<p>Кроме того, иногда полезно ставить ограничение на время запроса. Например, хочется генерировать ошибку, если запрос висит более 10 секунд.</p>
<p>
Для этого сразу после send()  через setTimeout ставится вызов обработчика ошибки, который очищается при получении ответа и обрывает запрос с генерацией ошибки,
если истекли 10 секунд.</p>

<p>Таймаут на синхронный запрос ставить нельзя, браузер может висеть долго-долго.. А вот на асинхронный - пожалуйста.</p>

<p>Этот пример демонстрирует такой таймаут.</p>
<pre>
var xmlhttp = getXmlHttp()
xmlhttp.open("POST", "/someurl", true);

xmlhttp.onreadystatechange=function(){
  if (xmlhttp.readyState != 4) return

  clearTimeout(timeout) // очистить таймаут при наступлении readyState 4

  if (xmlhttp.status == 200) {
      // Все ок
      ...
      alert(xmlhttp.responseText);
      ...
  } else {
      handleError(xmlhttp.statusText) // вызвать обработчик ошибки с текстом ответа
  }
}

xmlhttp.send("a=5&amp;b=4");
// Таймаут 10 секунд
var timeout = setTimeout( function(){ xmlhttp.abort(); handleError("Time over") }, 10000);

function handleError(message) {
  // обработчик ошибки
  ...
  alert("Ошибка: "+message)
  ...
}
</pre>

 <a name="method"></a>
    <h2>Методы объекта XMLHttpRequest</h2>

    <h3 id="method_open">open()</h3>

        Варианты вызова:
<ul>
<li>open( method, URL )</li>
<li>open( method, URL, async )</li>
<li>open( method, URL, async, userName )</li>
<li>open( method, URL, async, userName, password )</li>
</li></ul>

<p>Первый параметр <strong>method</strong> - HTTP-метод. Как правило, используется GET либо POST, хотя доступны и более экзотические, вроде TRACE/DELETE/PUT и т.п.</p>

<p><strong>URL</strong> - адрес запроса. Можно использовать не только HTTP/HTTPS, но и другие протоколы, например FTP и FILE://. При этом есть ограничения безопасности, так называемая
"same origin policy": запрос со страницы можно отправлять только на тот домен и порт, с которого она пришла.</p>
<p>Ниже это ограничение и способы обхода будут рассмотрены подробнее.</p>

<p><strong>async</strong> = true задает асинхронные запросы, эта тема была поднята выше.</p>

<p><strong>userName</strong>, <strong>password</strong> - данные для HTTP-авторизации.</p>


<h3 id="method_send">send()</h3>

<p>Отсылает запрос. Аргумент - <i>тело</i> запроса. Например, GET-запроса тела нет, поэтому используется <code>send(null)</code>, а для POST-запросов тело содержит параметры запроса.</p>

<h3 id="method_abort">abort()</h3>

<p>Вызов этого метода xmlhttp.abort() обрывает текущий запрос.</p>

<p>Здесь есть одно НО для браузера Internet Explorer. Успешный вызов abort() на самом деле может не обрывать соединение,
а оставлять его в подвешенном состоянии на некоторый таймаут (20-30 секунд). Отловить такие повисшие соединения можно через прокси для отладки, например, Fiddler.
</p>

<p>У браузера есть лимит: не более 2 одновременных соединений с одним доменом-портом. Т.е, если два соединения уже висят (и отвиснут по таймауту), то третье открыто не
будет, пока одно из них не умрет. Надеюсь, Вы с такой проблемой не столкнетесь. Ее можно обойти использованием кросс-доменных XmlHttpRequest.</p>

<h3>setRequestHeader(name, value)</h3>

Устанавливает заголовок <strong>name</strong> запроса со значением <strong>value</strong>. Если заголовок с таким <strong>name</strong> уже есть - он заменяется.

Например,
<pre>
xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
</pre>

<h3>getAllResponseHeaders()</h3>

Возвращает строку со всеми HTTP-заголовками ответа сервера.

<h3>getResponseHeader(headerName)</h3>

Возвращает значение заголовка ответа сервера с именем <strong>headerName</strong>.

<a name="props"></a>
    <h2>Свойства объекта XMLHttpRequest</h2>

        <h3>onreadystatechange</h3>

        Ссылается на функцию-обработчик состояний запроса. В некоторых браузерах функция имеет аргумент - событие. Не используйте его, он совершенно лишний.

        <h3>readyState</h3>

        Номер состояния запроса от 0 до 4. Используйте только 4 ("completed").

        <h3>responseText</h3>
        Текст ответа сервера. Полный текст есть только при readyState=4, ряд браузеров дают доступ к полученной части ответа сервера при readyState=3.

        <h3>responseXML</h3>
        <p>Ответ сервера в виде XML, при readyState=4. </p>

        <p>Это свойство хранит объект типа XML document, с которым можно обращаться так же, как с обычным document. Например,</p>

        <pre>var authorElem = xmlhttp.responseXML.getElementById('author')</pre>

        <p>Чтобы браузер распарсил ответ сервера в свойство responseXML, в ответе должен быть заголовок Content-Type: text/xml.
        <br/>Иначе свойство responseXML будет равно null.</p>

        <h3>status</h3>

<p>     Для HTTP-запросов - статусный код ответа сервера: 200 - OK, 404 - Not Found, и т.п. Браузер Internet Explorer может также присвоить status код ошибки WinInet,
        например 12029 для ошибки "cannot connect".</p>

        <p>Запросы по протоколам FTP, FILE:// не возвращают статуса, поэтому нормальным для них является status=0.</p>

        <h3>statusText</h3>

        <p>Текстовая расшифровка status, например "Not Found" или "OK".
</p>


<h2 id="encoding">GET и POST-запросы. Кодировка.</h2>

<p>Во время обычного submit'а формы браузер сам кодирует значения полей и составляет тело GET/POST-запроса для посылки на сервер. При работе через XmlHttpRequest, это нужно делать самим, в javascript-коде. Большинство проблем и вопросов здесь связано с непониманием, где и какое кодирование нужно осуществлять.</p>

<p>Вначале рассмотрим общее кодирование запросов, ниже - правильную работу с русским языком для windows-1251.</p>

<p>Существуют два вида кодирования HTTP-запроса. Основной - urlencoded, он же - стандартное кодирование URL. Пробел представляется как %20, русские буквы и большинство спецсимволов кодируются, английские буквы и дефис оставляются как есть.</p>

<p>Способ, которым следует кодировать данные формы при submit'е, задается в ее HTML-таге:</p>
<pre>
&lt;form method="get"&gt; // метод GET с кодировкой по умолчанию
&lt;form method="post" enctype="application/x-www-form-urlencoded"&gt; // enctype явно задает кодировку
&lt;form method="post"&gt; // метод POST с кодировкой по умолчанию (urlencoded, как и предыдущая форма)
</pre>

<p>Если форма submit'ится обычным образом, то браузер сам кодирует (urlencode) название и значение каждого поля данных (<code>input</code> и т.п.) и отсылает форму на сервер в закодированном виде.</p>

<p>Формируя XmlHttpRequest, мы должны формировать запрос "руками", кодируя поля функцией <code>encodeURIComponent</code>.</p>

<p>Конечно, пропускать через encodeURIComponent стоит только те переменные, в которых могут быть спецсимволы или не английские буквы, т.е которые и будут как раз закодированы.</p>

<p>Например, для посылки GET-запроса с произвольными параметрами name и surname, их необходимо закодировать вот так:</p>

<pre>
// Пример с GET
...
var params = 'name=' + encodeURIComponent(name) + '&amp;surname=' + encodeURIComponent(surname)
xmlhttp.open("GET", '/script.html?'+params, true)
...
xmlhttp.send(null)
</pre>

<p>В методе POST параметры передаются не в URL, а в теле, посылаемом через <code>send()</code>. Поэтому <code>params</code> нужно указывать не в адресе, а при вызове <code>send()</code></p>

<p>Кроме того, при POST <b>обязателен</b> заголовок Content-Type, содержащий кодировку. Это указание для сервера - как обрабатывать (раскодировать) пришедший запрос.
</p>

<pre>
// Пример с POST
...
var params = 'name=' + encodeURIComponent(name) + '&amp;surname=' + encodeURIComponent(surname)
xmlhttp.open("POST", '/script.html', true)
xmlhttp.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded')
...
xmlhttp.send(params)
</pre>

<p>Заголовки Content-Length, Connection в POST-запросах, хотя их и содержат некоторые &quot;руководства&quot;, обычно не нужны. Используйте их, только если Вы действительно знаете, что делаете.
</p>

<h3>Запросы multipart/form-data</h3>
<p>Второй способ кодирования - это отсутствие кодирования. Например, кодировать не нужно для пересылки файлов. Он указывается в форме (только для POST) так:</p>
<pre>
&lt;form method="post" enctype="multipart/form-data"&gt;
</pre>

<p>В этом случае при отправке данных на сервер ничего не кодируется. А сервер, со своей стороны, посмотрев на Content-Type(=multipart/form-data), поймет, что пришло.
</p>
<p>Возможности XmlHttpRequest позволяют создать запрос с любым телом. Например, можно вручную сделать POST-запрос, загружающий на сервер файл. Функционал создания
таких запросов есть, в частности, во фреймворке <a href="http://dojotoolkit.org">dojo</a>. Но можно реализовать его и самому, прочитав о нужном формате тела POST и заголовках.</p>

<h3>Кодировка (языковая)</h3>

<p>Если Вы используете только UTF-8 - пропустите эту секцию.</p>

<p>Все идущие на сервер параметры GET/POST, кроме случая multipart/form-data, кодируются в UTF-8. Не в кодировке страницы, а именно в UTF-8. Поэтому, например, в PHP их нужно при необходимости перекодировать функцией iconv.</p>

<pre>
// ajax.php
$name = iconv('UTF8','CP1251',$_GET['name']);
</pre>

<p>С другой стороны, ответ с сервера браузер воспринимает именно в той кодировке, которая указана в заголовке ответа Content-Type. Т.е, опять же, в PHP, чтобы браузер воспринял ответ в windows-1251 и нормально отобразил данные на странице в  windows-1251,
нужно послать заголовок с кодировкой в php-коде, например так:</p>
<pre>
// ajax.php
header('Content-Type: text/plain; charset=windows-1251');
</pre>

Или же, такой заголовок должен добавить сервер. Например, в apache автоматически добавляется кодировка опцией:
<pre>
# в конфиге апача
AddDefaultCharset windows-1251
</pre>

        <a name="problem"></a>
        <h2>Частые проблемы</h2>

        <h3>Кеширование</h3>

<p>     Многие браузеры поддерживают кеширование ответов на XmlHttpRequest запросы. При этом реализации кеширования немного разные.
</p>

<p>     Например, при повторном XmlHttpRequest на тот же URL, Firefox посылает запрос с заголовком "If-Modified-Since" со значением,
        указанным в заголовке "Last-Modified" предыдущего ответа.
</p>

<p>А Internet Explorer делает так, только когда кешированный ответ устарел, т.е после времени из заголовка "Expires" предыдущего ответа. Поэтому, кстати, многие думают,
что Internet Explorer вообще не очищает кеш ответов.</p>

<p>Самое простое решение проблемы - просто убрать кеширование. Например, при помощи заголовков, или добавлением случайного параметра в URL типа:</p>
<pre>
xmlhttp.open("GET", "/service.php?r="+Math.random(), true)
</pre>

<p>Есть, однако, ряд случаев, когда кеширование XMLHttpRequest браузером полезно, улучшает время ответа и экономит трафик, просто нужно уметь его использовать.
</p>

<p>Пример демонстрирует универсальный код работы с кешем для Internet Explorer и Firefox. Этот пример обеспечивает посылку "If-Modified-Sinse"-заголовка IE при обращениях к закешированному запросу.</p>

<pre>
var xmlhttp = getXmlHttp()
xmlhttp.open("GET", uri, false); // синхронный запрос для примера
xmlhttp.send(null);
if(!xmlhttp.getResponseHeader("Date")) {  // 1
  var cached = xmlhttp;
  xmlhttp = getXmlHttp()
  var ifModifiedSince = cached.getResponseHeader("Last-Modified");
  ifModifiedSince = (ifModifiedSince) ? ifModifiedSince : new Date(0); // January 1, 1970
  xmlhttp.open("GET", uri, false);
  xmlhttp.setRequestHeader("If-Modified-Since", ifModifiedSince);
  xmlhttp.send(null);
  if(xmlhttp.status == 304)  {
    xmlhttp = cached;
  }
}
</pre>

<h4>Разбор примера работы с кешем</h4>
<p>
Внешний тест (1) опирается на то, что в Internet Explorer, если запрос возвращается из кеша без перепроверки, заголовок Date - пустая строка. Поэтому при этом нужно сделать дополнительный запрос, который как раз и будет реальным запросом к серверу.
</p>

<p>Когда делаем дополнительный запрос, что ссылку на кешированый запрос сохраняем, т.к если код ответа дополнительного запроса - "304 Not Modified", то его тело будет пустой строкой, и нужно будет вернуться к кешированному объекту.</p>

<p>Для оптимизации, можно не создавать новый объект XmlHttpRequest, а сохранить данные из существующего и
использовать заново его же.</p>

<p>Пример выше опирается на то, что сервер всегда выдает заголовок "Date", что верно для большинства конфигураций.
В нем делается синхронный запрос. В асинхронном случае, проверку на Date и т.д нужно делать после получения ответа в функции-обработчике onreadystate.</p>

<h3>Повторное использование объекта XmlHttpRequest</h3>

<p>В Internet Explorer, если open() вызван после установки onreadystatechange, может быть проблема с повторным использованием этого XmlHttpRequest. </p>
<p>Чтобы использовать заново XmlHttpRequest, сначала вызывайте метод open(), а затем - присваивайте onreadystatechange. Это нужно из-за того, что IE самостоятельно очищает
объект XmlHttpRequest в методе open(), если его статус "completed".</p>

<p>Вызывать abort() для перенаправления запроса на другой URL не нужно, даже если текущий запрос еще не завершился.</p>

<h3>Повторный XmlHttp-запрос после abort() зависает</h3>

<p>С этой проблемой я сталкивался только в IE под Windows. Ее причины - в том, что abort() не обрывает TCP-соединение, а оставляет его висеть до наступления таймаута (см. <a href="#method_abort">метод abort()</a>). Если же к домену есть два TCP-соединения (даже ждущие таймаута), то третье будет висеть, пока какое-то из них не помрет.</p>

<h3>XmlHttpRequest виснет в IE7 (много табов)</h3>

<p>Проблема иногда возникает при отладке приложений с длинными XmlHttpRequest, которые висят и ждут события с сервера.</p>

<p>Она связана с ограничением в 2 одновременных соединения к одному домену. Точнее, с тем фактом, что это ограничение в IE7 действует <u>не на один таб, а на все</u>. Так что, если есть два таба с непрерывным соединением, то при открытии третьего таба - XmlHttpRequest с него к тому же домену просто зависнет и будет ждать окончания одного из двух предыдущих запросов.</p>

<h3>Утечки памяти</h3>

<p>В Internet Explorer объект XmlHttpRequest принадлежит миру DOM/COM, а Javascript-функция - миру Javascript. Присваивание <code>xmlhttp.onreadystatechange = function() { ... }</code> задает неявную
круговую связь: xmlhttp ссылается на функцию через onreadystatechange, а функция, через свою область видимости - видит (ссылается на) xmlhttp.
</p>

<p>Невозможность обнаружить и оборвать такую связь во многих (до IE 6,7 редакции июня 2007?) версиях Internet Explorer приводит к тому, что XmlHttpRequest вместе
с ответом сервера, функция-обработчик и всё замыкание прочно оседают в памяти до перезагрузки браузера.</p>

<p>Чтобы этого избежать, ряд фреймворков (YUI, dojo...) вообще не ставят onreadystatechange, а вместо этого через setTimeout проверяют его readyState каждые 10 миллисекунд.
Это разрывает круговую связку xmlhttp &lt;-&gt; onreadystatechange, и утечка памяти не грозит даже в самых глючных браузерах.
</p>

<h3>Firefox ставит responseXML вида &lt;parseerror&gt;...&lt;/parseerror&gt;</h3>

<p>Да, у браузеров типа Mozilla это такой способ сказать, что документ невалидный.</p>

<h2 id="security">Ограничения безопасности. Кросс-доменный XMLHttpRequest</h2>

<p>Для ограничения XmlHttpRequest используется философия "Same Origin Policy". Она очень проста - каждый сайт в своей песочнице. Запрос можно делать только на адреса
с тем же протоколом, доменом, портом, что и текущая страница.</p>

<p>Т.е, со страницы на адресе http://site.com нельзя сделать XmlHttpRequest на адрес <b>https</b>://site.com, http://site.com:<b>81</b> или http://<b>othersite.com</b></p>
<p>Это создает проблему, если хочется взять контент с другого сайта. Как правило, в этом случае вместо XmlHttpRequest используются другие средства, например, загрузка через
динамически создаваемый тег &lt;script&gt;. Но, конечно, XmlHttpRequest удобнее и мощнее, поэтому некоторые средства для кросс-доменных запросов все же придуманы.</p>

<h3>Проксирование</h3>

<p>Самый простой способ обойти это ограничение - проксирование. Допустим, мы хотим сделать запрос с http://site.com на http://remote.com/get.html.</p>

<p>Чтобы обойти ограничение, вместо указания remote.com в методе open(), там ставится специальный URL вида http://site.com/proxy/remote.com/get.html. Так что запрос приходит на наш веб-сервер, который проксирует его на сервер  site.com, который в свою очередь обрабатывает этот запрос, как нужно.
</p>

<p>Если remote.com находится на другом сервере, то серверу site.com придется проксировать посетителю как запрос, так и ответ. При этом, разумеется, никак не будут задействованы куки remote.com, так что не получится отдельной авторизации, учета пользователей или чтото в этом роде с отдельными куками.</p>

<p>Проксирование настраивается соответствующим модулем (mod_proxy, proxy module и т.п.) веб-сервера для всех адресов, начинающихся на /proxy.</p>

<p>Например, при использовании web-сервера Apache, для проксирования нужны директивы ProxyPass, ProxyPassReverse. Кроме того, доступны еще модули, которые по необходимости правят урлы, разархивируют контент <a href="http://www.askapache.com/htaccess/reverse-proxy-apache.html">и т.п.</a></p>


<h3>Использование наддомена</h3>

Часто кроссбраузерные запросы - это

<ol>
<li>Способ обойти ограничения в 2 одновременных соединения к одному домену-порту.</li>
<li>Способ использовать два разных сервера в общении с посетителем. Например, на chat.site.ru - чат-демон, на www.site.ru - веб-сервер.</li></ol>

<p>Кросс-доменные запросы с поддомена типа http://a.site.com, http://b.site.com на базовый домен site.com допустимы при использовании свойства document.domain, которое надо установить в site.com
</p>

<pre>
// на странице a.site.com
...
document.domain='site.com'
...
// все, теперь могу делать XmlHttpRequest на site.com
xmlhttp.open(..'http://site.com/feedme.php'..)
</pre>

<h4>Запрос на старый домен</h4>

<p>В браузере Internet Explorer, чтобы сделать запрос на старый домен a.site.com, нужно вернуть свойство document.domain обратно. В остальных браузерах это приводит к ошибке, поэтому можно оформить код типа такого:</p>

<pre>
var oldDomain = document.domain
document.domain = "site.com"

... работаем с site.com ...

try {
    // для IE, в остальных браузерах ошибка...
    document.domain = oldDomain;
} catch(e) {  /* ... но в них все и так работает */ }

... работаем с a.site.com ...
</pre>

<h4>Same origin и фреймы</h4>

<p>Приятным бонусом свойства document.domain является возможность коммуникации между фреймами/ифреймами на одном домене.</p>

<p>То есть, например, если 
<ul>
<li>во фрейме с адреса http://a.site.com установлен document.domain='site.com',</li>
<li>на фрейме с адреса http://b.site.com установлен домен document.domain='site.com'</li>
<li>на фрейме с адреса http://site.com установлен (обязательно!) домен document.domain='site.com'</li>
</ul>

<p>То эти три фрейма могут свободно общаться посредством javascript и XmlHttpRequest. </p>

Обычно такая коммуникация используется при создании чатов/событий с сервера, когда на site.com находится основной веб-сервер, а на chat.site.com висит чат-демон.

<h4>Internet Explorer trusted zone</h4>

<p>
Любые запросы допустимы между сайтами, находящимися в доверенной (trusted) зоне Internet Explorer. Так что, внутренний корпоративный портал может быть у всех пользователей в этой зоне, и он сможет делать запросы к любым сайтам.</p>

<h3>XhrIframeProxy</h3>
<p>
Еще один хитрый подход называется <a href="http://www.google.ru/search?q=xhriframeproxy">XHRIframeProxy</a>, и позволяет делать XmlHttpRequest к любым доменам при помощи хитрого iframe-хака. Он основан на том, что фреймы с разных доменов могут читать и менять друг у друга anchor, т.е часть адреса после решетки '#'. За счет этого организуется специальный протокол, по которому "проксируется" XmlHttpRequest.
</p>

<p>Этот метод, в принципе, вполне жизнеспособен, особенно для небольшого объема данных.</p>


<h3>Кросс-доменные запросы в FF3/IE8/Opera9..</h3>

<p>В спецификации HTML 5 предусмотрены кросс-доменные запросы <a href="http://www.whatwg.org/specs/web-apps/current-work/multipage/section-crossDocumentMessages.html#crossDocumentMessages">postMessage</a>.</p>

<p>Создатели Firefox и Opera реализовали этот вариант, см. например MDC: <a href="http://developer.mozilla.org/en/docs/DOM:window.postMessage">DOM:window.postMessage</a>.</p>

<p>Разработчики IE8 пошли другим путем и предлагают <a href="http://msdn.microsoft.com/en-us/library/cc288060.aspx">XDomainRequest</a>.</p>

<p>Оба способа вполне жизнеспособны и уже пригодны для использования в интранет-приложениях, когда на всех машинах администратор ставит одинаковый браузер, например, Firefox 3 ;)</p>

<h2 id="frameworks">Поддержка в библиотеках и фреймворках</h2>

<p>Практически каждая javascript-библиотека или javascript-фреймворк включает в том или ином виде поддержку XmlHttpRequest-запросов и других способов прозрачного общения с сервером. Берите фреймворк по другим
параметрам, а какая-то поддержка так обязательно будет.
</p>

<h3>Javascript-библиотеки</h3>

<h4>Dojo toolkit</h4>

<p>Наиболее профессионально общение с сервером, на мой взгляд, сделано в <a href="http://dojotoolkit.org">dojo</a>. Для удобства работы с асинхронными вызовами, в
dojo и <a href="http://mochikit.com">Mochikit</a> используется специальный объект Deferred. Умеет посылать формы, отменять запросы, позволяет строить сложные цепочки асинхронных вызовов. В dojo для этого используется вызов <code>dojo.xhrGet</code>, который позволяет указывать обработчик, таймаут и формат запроса (например, JSON). Также умеет предотвращать кеширование (<code>preventCache</code>), передавать объекты/формы с файлами.</p>

<p>Надо сказать, что в dojo есть еще масса других транспортов, которые позволяют вытворять со связью клиент-сервер все, что только возможно и невозможно... Надо только разобраться как, на момент написания доки, откровенно говоря, слабоваты.</p>

<h4>Yahoo UI (YUI)</h4>

<p>В <a href="http://developer.yahoo.com/yui/">Yahoo UI</a> соединениями с сервером заведует <a href="http://developer.yahoo.com/yui/docs/module_connection.html">Connection Manager</a>. Главная фунция <code>asyncRequest</code> принимает в качестве одного из параметров (<code>callback</code>) объект, который позволяет <a href="http://developer.yahoo.com/yui/examples/connection/global_customevents.html">подписываться на события</a>, <a href="http://developer.yahoo.com/yui/examples/connection/abort.html">указывать timeout</a> и посылать на сервер объект. Кроме того можно указывать временной промежуток для автоматических опросов. Например, опрашивать новости с сервера каждые 3 секунды. Метод <code>setForm</code> передает форму, умеет загружать файлы.</p>

<h4>Prototype</h4>

<p>Во фреймворке <a href="http://www.prototypejs.com/">prototype</a> Ajax представлен рядом классов вида Ajax.*. В сочетании с другими методами библиотеки - предоставляет весь стандартный функционал. Кроме того - приятный бонус: Ajax.PeriodicalUpdater умеет легко обновлять HTML-элемент с сервера и гибко увеличивать промежуток между опросами при проблемах серверной части.</p>

<h4>JsHttpRequest</h4>

<p>Есть еще библиотека <a href="http://dklab.ru/lib/JsHttpRequest/">JsHttpRequest</a>, которая набрала популярность за счет русской документации и коммунити. Весь базовый функционал у нее есть. Лично я ни разу не пользовался, но говорят - работает. Если Вы не знаете английского языка и не нуждаетесь в интеграции AJAX с более общим javascript-фреймворком - возможно, эта библиотека подойдет.</a>

<h3>Серверные библиотеки</h3>

<p>Есть специальные серверные библиотеки, которые упрощают работу с XmlHttpRequest, организуя не только javascript-часть, но и серверную тоже. Они обычно умеют, например, отображать серверные функции на php в javascript-аналоги. При вызове такого javascript-аналога библиотека сама сделает запрос на сервер, обработает его на сервере, вызовет серверную функцию и вернет ее результат.</p>

<p>Для PHP одной из лучших библиотек является <a href="http://www.xajaxproject.org/">XAJAX</a>, для Java - <a href="http://getahead.org/dwr">DWR</a>.</p>

<h3>...А если...</h3>

<p>... Ну а если фреймворка не хочется, или надо то, чего во фреймворках нет, надеюсь, после прочтения этой доки, Вы без проблем реализуете все сами.</p>


<div id="footer-div"><a href="#top">Наверх</a> <a href="http://forum.javascript.ru">Форум</a>
<a href="http://xmlhttprequest.ru/w3c">Спецификация W3C</a><br/>
<a href="http://javascript.ru">Полезные статьи на http://javascript.ru</a>
</div>

P.S. Комментарии закрыты. Вопросы прошу задавать на форуме <a href="http://javascript.ru/forum/ajax">http://javascript.ru/forum/ajax</a>


<div class="book-navigation"><div class="page-links clear-block"></div></div></div>
        <div class="links">&raquo; <ul class="links inline"><li class="first last book_printer"><a href="/book/export/html/4" title="Показать версию этой подшивки со всеми дочерними страницами в виде, удобном для печати." class="book_printer">версия для печати</a></li>
</ul></div>
    </div>
<div id="comments"><a id="comment-3"></a>
<div class="comment">
    <div class="submitted">Опубликовано Кирилл (не зарегистрирован) в 22.12.2007 в 22:20.</div>
  <div class="content"><p>Очень хорошо спасибо вам за сайт</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5"></a>
<div class="comment">
    <div class="submitted">Опубликовано yevgeniy (не зарегистрирован) в 01.01.2008 в 03:26.</div>
  <div class="content"><p>Большое спасибо....<br />
Как ни странн,о разбирал по косточкам Extjs_dot_com... а знания не хватило... спасибо еще раз за понятный материал и с наступившим Новым годом!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-7"></a>
<div class="comment">
    <div class="submitted">Опубликовано Andrey (не зарегистрирован) в 10.01.2008 в 15:16.</div>
  <div class="content"><p>Спасибо за столь подробно изложенный материал</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-8"></a>
<div class="comment">
    <div class="submitted">Опубликовано Offi (не зарегистрирован) в 16.01.2008 в 11:07.</div>
  <div class="content"><p>Спасибо, очень многое прояснилось.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-9"></a>
<div class="comment">
    <div class="submitted">Опубликовано chapluck (не зарегистрирован) в 16.01.2008 в 14:23.</div>
  <div class="content"><p>Замечательная статья, которая помогла мне разобраться с моими многодневными мытырствованиями!<br />
Странно только что  такие статьи как <a href="http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_r_2.html" title="http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_r_2.html">http://www.quirksmode.org/blog/archives/2005/09/xmlhttp_notes_r_2.html</a> были написаны очень давно а положение вещей как я понял так и не изменилось, несмотря на работу коммитета стандартизации! везде разногласия! и еще я не понял почему нельзя обратиться к responseText в IE вне обработчика события... всмысле в тот момент, пока он ждет закрытия соединения с сервером, с помощью setTimeout(function(){alert(xhr.responseText)}, 500) - к примеру</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-15"></a>
<div class="comment">
    <div class="submitted">Опубликовано Трактор (не зарегистрирован) в 06.04.2008 в 11:57.</div>
  <div class="content"><p>Спасибо огромное! Клиенты всё больше требуют web морд, а куда без javascript? Три дня искал информацию. Набрёл на <a href="http://javascript.ru/" title="http://javascript.ru/">http://javascript.ru/</a> и <a href="http://xmlhttprequest.ru/" title="http://xmlhttprequest.ru/">http://xmlhttprequest.ru/</a> и счастье настало!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-17"></a>
<div class="comment">
    <div class="submitted">Опубликовано Nastia (не зарегистрирован) в 30.04.2008 в 09:05.</div>
  <div class="content"><p>Спасибо, все сразу стало очень понятно</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-21"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="/user/1" title="Информация о пользователе.">admin</a> в 24.05.2008 в 06:22.</div>
  <div class="content"><p>Здесь публикуются комментарии конкретно по статье. Все вопросы - просьба задавать <a href="http://forum.javascript.ru">на форуме</a>, он для того и существует :)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-24"></a>
<div class="comment">
    <div class="submitted">Опубликовано J-Pig (не зарегистрирован) в 24.06.2008 в 07:20.</div>
  <div class="content"><p>Великолепно! побольше бы таких статей, интересно, а объекти ActiveXObject("Msxml2.XMLHTTP") и  ActiveXObject("Microsoft.XMLHTTP") обладают теми же методами и свойствами, может кто знает?</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-28"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="/user/1" title="Информация о пользователе.">admin</a> в 21.07.2008 в 18:44.</div>
  <div class="content"><p>Msxml2.XMLHTTP и Microsoft.XMLHTTP обладают одинаковыми методами и свойствами, хотя и принадлежат разным версиям библиотеки MSXML.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-29"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 30.07.2008 в 07:26.</div>
  <div class="content"><p>Очень помогло, спасибо</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-30"></a>
<div class="comment">
    <div class="submitted">Опубликовано Elvis (не зарегистрирован) в 20.08.2008 в 08:21.</div>
  <div class="content"><p>Огромное человеческое спсибо! Только что пофиксил баг, оказалось косяк с кодировкой.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-31"></a>
<div class="comment">
    <div class="submitted">Опубликовано sd1074 (не зарегистрирован) в 23.08.2008 в 09:50.</div>
  <div class="content"><p>Очень полезно, спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-3509"></a>
<div class="comment">
    <div class="submitted">Опубликовано macint0sh (не зарегистрирован) в 20.10.2008 в 11:45.</div>
  <div class="content"><p>Относительно недавно стал изучать(более плотно) JavaScript, и ваши ресурсы мне в этом очень помогают!<br />
Огромное вам спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5814"></a>
<div class="comment">
    <div class="submitted">Опубликовано Aigerimka (не зарегистрирован) в 03.12.2008 в 13:27.</div>
  <div class="content"><p>Спасибо автору, очень содержательно и понятно=))</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5819"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 09.12.2008 в 23:54.</div>
  <div class="content"><p>Большое спасибо! Весь день искала про вопросы кодировки при посылке запроса, помогло!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5820"></a>
<div class="comment">
    <div class="submitted">Опубликовано KoshMur (не зарегистрирован) в 10.12.2008 в 13:12.</div>
  <div class="content"><p>Нет слов - одни эмоции :) Спасибо за просто изложенную, но полезную прикладную статью.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5821"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 04.01.2009 в 12:02.</div>
  <div class="content"><p>огромное спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5822"></a>
<div class="comment">
    <div class="submitted">Опубликовано Integrable (не зарегистрирован) в 07.01.2009 в 20:14.</div>
  <div class="content"><p>Добрый день. Вопрос насчет Кросс-доменного XMLHttpRequest:<br />
как обойти ограничения, если джаваскрипт работает с закладок пользователя и обращается "как-бы" к удаленному серверу?</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5823"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://alekciy.ru">alekciy</a> (не зарегистрирован) в 12.01.2009 в 11:15.</div>
  <div class="content"><p>&gt;Возможности XmlHttpRequest позволяют создать запрос с любым телом.<br />
&gt;Например, можно вручную сделать POST-запрос, загружающий на сервер файл.</p>
<p>Очень интересно было бы увидеть пример кода с использованием "чистого" XHR (т.е. без притяжки iframe).</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5824"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://alekciy.ru/">alekciy</a> (не зарегистрирован) в 12.01.2009 в 11:30.</div>
  <div class="content"><p>&gt;Все идущие на сервер параметры GET/POST, кроме случая multipart/form-data, кодируются в UTF-8.<br />
Хотелось бы уточнить, проверял ли автор сам это утверждение? Если да, то на каком конфиге?</p>
<p>Сам делал неоднократные проверки на Apache2.0.x-2.2.x с mod_php 5.x.x и даже при urlencoded, который по сути не привязан ни к одной из кодовых страниц, получаю в самом интерпретаторе строки именно в той кодировке, в какой была отправлена страница на клиент хотя даже через снифер видно, что браузер используемую charset не указывает! Где, что и как это происходит детально времени не было, но видимо таки его придется выкроить...</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5827"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 04.02.2009 в 19:48.</div>
  <div class="content"><p>Это просто пиздец - пример всему рутырнету.<br />
Неделю читаю всякое фуфло - никто толком объяснить ничего не может, и статью нормальную написать.</p>
<p>РЕСПЕКТ АВТОРУ(АМ) - Статьтя супергрейт!!!!!!<br />
страничку уже засейвил на крайняк</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5830"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 16.02.2009 в 08:50.</div>
  <div class="content"><p>Спасибо автору</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5837"></a>
<div class="comment">
    <div class="submitted">Опубликовано mayhem (не зарегистрирован) в 17.03.2009 в 14:51.</div>
  <div class="content"><p>вы за что Котерова обижаете? У него очень хорошая библиотека</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5838"></a>
<div class="comment">
    <div class="submitted">Опубликовано Александр (не зарегистрирован) в 22.03.2009 в 21:18.</div>
  <div class="content"><p>Отличная статья! Помогла разобраться. Спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5839"></a>
<div class="comment">
    <div class="submitted">Опубликовано andi (не зарегистрирован) в 25.03.2009 в 08:05.</div>
  <div class="content"><p>«Если Вы используете только UTF-8 - пропустите эту секцию.<br />
Все идущие на сервер параметры GET/POST … кодируются в UTF-8.»</p>
<p>давным-давно я столкнулся с этим "недоразумением". запрос нормально уходил<br />
на сервер, обрабатывался, и  возвращался нужный мне результат. так было во всех<br />
браузерах, кроме ie. оказалось, что всенародно любимый браузер отправляет<br />
данные в 1251 (скорее всего, в кодировке, в которой представлена страница.<br />
а я то на сервере ждал utf8, согласно спецификации). :)</p>
<p>ps: И, кстати, было справедливое замечание: а где jQuery? Замечательный фреймворк,<br />
поудобнее Prototype будет, да и побыстрее.</p>
<p>ps2: А работа с ajax в JsHttpRequest всё-таки, имхо, менее удобна, чем в jQuery.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5840"></a>
<div class="comment">
    <div class="submitted">Опубликовано andi (не зарегистрирован) в 25.03.2009 в 08:16.</div>
  <div class="content"><p>to arvitaly:</p>
<p>насколько мне известно, ни один браузер не предоставляет доступа к загружаемым файлам.<br />
плясать следует от покоцанного в спецификации html4 (но возвращённого в html5)<br />
аттрибута target.</p>
<p>смысл такой: создаётся невидимый iframe, в который и "загружается" форма со всем<br />
её содержимым (включая, конечно же, и файл).</p>
<p>т. е., нужно что-то вроде:</p>
<p>содержимое формы</p>
<p>после отправки формы страница не перезагружается, а результат запроса будет<br />
направлен в iframe (html-страница!). для сигнализирования того, что запрос<br />
завёршён, нужно в эту страницу поместить js-код, который должен быть выполнен<br />
в случае успешной загрузки (в простейшем случае можно обойтись и<br />
alert('файлы загружены');, но ведь наверняка же с формой что-то нужно будет<br />
сделать (как минимум, убрать) :)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5843"></a>
<div class="comment">
    <div class="submitted">Опубликовано Казаков Николай (не зарегистрирован) в 02.04.2009 в 08:07.</div>
  <div class="content"><p>Автор шикарен, статья отличная =) Кодировку только тут нашел, толковое и ясное объяснение! Спс =)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5848"></a>
<div class="comment">
    <div class="submitted">Опубликовано Вася (не зарегистрирован) в 12.04.2009 в 22:50.</div>
  <div class="content"><p>Спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5849"></a>
<div class="comment">
    <div class="submitted">Опубликовано RJ Presto (не зарегистрирован) в 13.04.2009 в 08:24.</div>
  <div class="content"><p>статья - супер, спасибо :)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5850"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://alekciy.ru">alekciy</a> (не зарегистрирован) в 18.04.2009 в 22:41.</div>
  <div class="content"><p>Очень жаль, что автор абсолютно игнорирует вполне резонные вопросы (к примеру к кодировках) которые появились в каментах к статье. Вдвойне это удручает когда это может касаться неточностей/ошибка в изложенном материале.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5851"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="/user/1" title="Информация о пользователе.">admin</a> в 19.04.2009 в 08:34.</div>
  <div class="content"><p>Ответ по поводу эмуляции загрузки файла методом POST:</p>
<p>Вы уверены, что оно вам надо? Если да, то копать - в сторону формата POST-запроса. </p>
<p>Самое простое - посмотреть, как это реализовано в dojo.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5852"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="/user/1" title="Информация о пользователе.">admin</a> в 19.04.2009 в 08:36.</div>
  <div class="content"><p>Ответ вам, alekciy:</p>
<p>Я не вижу в комментариях вопросов, на которые нет ответа в статье. Задайте такой, если он у вас имеется! ;)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5856"></a>
<div class="comment">
    <div class="submitted">Опубликовано DrInch (не зарегистрирован) в 07.05.2009 в 04:53.</div>
  <div class="content"><p>У меня синхронный тест-пример работеат как асинхронный. В чем дело?<br />
Юзаю XP-SP2 + FF-3<br />
ЗЫ: На Мак-ОСи + Сфафри все работает как надо...</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5858"></a>
<div class="comment">
    <div class="submitted">Опубликовано Aton1ti (не зарегистрирован) в 14.05.2009 в 12:51.</div>
  <div class="content"><p>Столкнулся с проблемой, когда сервер возвращает </p>
<p>	WWW-Authenticate: Basic realm="..."<br />
        HTTP/1.0 401 Unauthorized</p>
<p>Браузер ( в моем случае Safari)   перехватывает обработку ответа и сам открывает окно  для ввода пароля. </p>
<p>			xmlHttp.onreadystatechange = function() {<br />
				if (xmlHttp.readyState == 4) {<br />
					alert("got Response: " +xmlHttp.status);<br />
					if (xmlHttp.status == 200) {<br />
						responceCallBack(xmlHttp.responseXML);<br />
						}<br />
					else if (xmlHttp.status == 401) {<br />
//--&gt;<br />
						alert(xmlHttp.responseText);    //  !!!!   Управление передается только  если в окне пароля сказать cansel<br />
//--&gt;<br />
					}<br />
					else {<br />
						//alert('Loading Error: ['+xmlHttp.status+'] '  +rxmlHttp.statusText);<br />
						}<br />
					}<br />
				};</p>
<p>знаю что у mozilla есть возможность с этим бороться   xmlHttp.mozBackgroundRequest = true;<br />
Подскажите как  проявляется такая ситуация с другими броузерами и как с ней бороться ?</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5862"></a>
<div class="comment">
    <div class="submitted">Опубликовано Строг и Капризен (не зарегистрирован) в 23.05.2009 в 20:08.</div>
  <div class="content"><p>Про кроссбраузерность вообще молчу... try - catch - throw оказались бесполезными, из чего напрашивается резонный вывод: автор статьи демонстративно "заботится" о кроссбраузерности, но сам, по-видимому, не удосужился убедиться на личном опыте в работоспособности данной части кода. Каждый должен сам додумывать код под используемый им браузер, если только это не IE. Последние версии FF, Opera - в пролёте, завелось только на IE7.<br />
 По определённым обстоятельствам был вынужден тестировать и отлаживать код не в он-лайне в Интернете, а на локальном сервере. Всё - на win32. Зачем вводить в заблуждение доверчивых читателей проверкой if(!xmlhttp.getResponseHeader("Date")) при попытке оптимизации кода загрузки (из кеша, если не обновилась, и с сервера, если там обновилась), если при запросе документа с локального сервера из htdocs и проверке с помощью alert(xmlhttp.getAllResponseHeaders()) никакого поля "Date:" нет (сниффером фильтровал локальный траффик - поле "Date:", как оказалось, присутствует)?! При запросе из Интернета - поле видно как сниффером, так и getAllResponseHeaders(). Но не всем же нужно запрашивать страницы с внешних ресурсов. Так что проверку, видимо, следует переделать с поля Дата на проверку по какому-то другому полю.<br />
 Статья хоть и полезная, но зелёная, как крыжовник и мае. Дозревать её надобно.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5863"></a>
<div class="comment">
    <div class="submitted">Опубликовано Строг и Капризен (не зарегистрирован) в 23.05.2009 в 22:40.</div>
  <div class="content"><p>Мысли вслух...<br />
 Хотя... в Интернете полно динамически генерируемых страниц, у которых всегда Дата свежая, в точности такая же, как в момент запроса. Поэтому, вполне возможно, что их сервера всегда (даже после первого запроса) возвращают это поле xmlhttprequest'у как свежее, в отличие от серверов, на которых страницы могут иметь определённый и приличный срок давности. Ещё раз замечу, что это касается только данного метода запроса ресурсов посредством xmlhttprequest, сниффер же всегда покажет пересылку поля Дата от сервера клиенту, даже если страница на сервере давно не модифицировалась. Дело в том, что как у браузера, так и у сервера согласно протокола общения ложен быть минимальный набор обязатальных и необхоимых полей, без которых инее общение просто либо не осуществится, либо начнётся, но не завершится. Можно либо заглянуть в документацию, либо опытным путём проверить на разных платформах, браузерах, типах страниц (статика, динамика), серверах, всегда ли сервер пригоняет поле Дата или нет.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5886"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://www.nik0las.ru/">Nikolas</a> (не зарегистрирован) в 16.06.2009 в 19:48.</div>
  <div class="content"><p>Вот тут описал еще один способ борьбы с утечками памяти: <a href="http://www.nik0las.ru/blog/2009/06/16/ajax_and_memory_leaks_at_ie.html" title="http://www.nik0las.ru/blog/2009/06/16/ajax_and_memory_leaks_at_ie.html">http://www.nik0las.ru/blog/2009/06/16/ajax_and_memory_leaks_at_ie.html</a></p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5888"></a>
<div class="comment">
    <div class="submitted">Опубликовано prike (не зарегистрирован) в 19.06.2009 в 09:58.</div>
  <div class="content"><p>Столкнулся с еще одной проблемой в Internet Explorer 6. Если несколько раз закрыть дочернее окно в котором данный грузятся асинхронно до завершения загрузки, XMLHttpRequest отваливается как в родительском так и вновь открываемых дочерних окнах. Внешне это выглядит так будто дочерние окна просто зависают и остаются висеть с белым фоном. Решение данной проблемы - вызывать метод abort принудительно при выгрузке документа (событие unload)<br />
Подробности описал здесь: <a href="http://javascript.ru/forum/ajax/4063-ie6-povisaet-pri-zakrytii-okna-v-kotorom-vypolnyaetsya-asinkhronnaya-zagruzka-dannykh.html" title="http://javascript.ru/forum/ajax/4063-ie6-povisaet-pri-zakrytii-okna-v-kotorom-vypolnyaetsya-asinkhronnaya-zagruzka-dannykh.html">http://javascript.ru/forum/ajax/4063-ie6-povisaet-pri-zakrytii-okna-v-ko...</a></p>
<p>Если автор сочтет нужным, можно было бы добавить упоминание об этом в раздел частых проблем.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5905"></a>
<div class="comment">
    <div class="submitted">Опубликовано Evgeny (не зарегистрирован) в 11.07.2009 в 13:35.</div>
  <div class="content"><p>Если всречу книгу от автора этой статьи, куплю!!!!)) Изложение материала просто супер!!!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5920"></a>
<div class="comment">
    <div class="submitted">Опубликовано Павел (не зарегистрирован) в 23.07.2009 в 12:25.</div>
  <div class="content"><p>Спасибо, статья действительно полезная. Вот только не работает такая конструкция:</p>
<p>На сервере (PHP 5.0.4):<br />
&lt;?<br />
...<br />
// Динамически формируется строка запроса<br />
$result=ibase_query($Connect,$SQLString);<br />
if ($result) {<br />
 echo ("Запрос выполнен успешно!");<br />
 ibase_commit($Connect);<br />
}<br />
?&gt;</p>
<p>У клиента:</p>
<p><code><br />
 function Button1Click(){<br />
....<br />
   xmlHttp.open("POST", "/invent_ajax/edit_device2.php", true);<br />
   xmlHttp.onreadystatechange = response;<br />
   xmlHttp.setRequestHeader("Content-Type","application/x-www-form-urlencoded; charset=UTF-8");<br />
   xmlHttp.send(UpdateFields); // передаем список полей формы с их значениями на сервер<br />
}<br />
 function response(){<br />
     if (xmlHttp.readyState == 4)<br />
       if (xmlHttp.status == 200)<br />
         alert(xmlHttp.responseText); // В этом месте возникает системная ошибка, но если не печатать ничего, то нет обратной связи с сервером...<br />
       else<br />
         alert("Error: status code is " + xmlHttp.status);<br />
 }</p>
<p></code></p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5921"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://alekciy.ru">alekciy</a> (не зарегистрирован) в 28.07.2009 в 00:41.</div>
  <div class="content"><p>Вопрос "Опубликовано alekciy (не зарегистрирован) в 12.01.2009 в 11:30." был более чем конретен. Повторю. Приходилось ли автору убеждаться в означенном утверждении на личном опыте?</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5929"></a>
<div class="comment">
    <div class="submitted">Опубликовано Частый Гость (не зарегистрирован) в 03.08.2009 в 02:51.</div>
  <div class="content"><p>Спасибо большое)))</p>
<p>На вашен сайте нашёл ответы на все вопросы))<br />
В процессе изучения в основном пользовался именно этим ресурсом..<br />
=))</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5931"></a>
<div class="comment">
    <div class="submitted">Опубликовано roman (не зарегистрирован) в 05.08.2009 в 20:31.</div>
  <div class="content"><p>подскажите, что означает результат запроса "Security Breach or Incorrect Firewall" ?<br />
по той же ссылке в браузере все загружается нормально</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5961"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 14.09.2009 в 09:57.</div>
  <div class="content"><p>Спасибо! Помогла статья и её комменты :)</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-5981"></a>
<div class="comment">
    <div class="submitted">Опубликовано Диомн (не зарегистрирован) в 30.09.2009 в 15:13.</div>
  <div class="content"><p>Спасибо, отличная статья!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6042"></a>
<div class="comment">
    <div class="submitted">Опубликовано Ayk (не зарегистрирован) в 28.11.2009 в 17:33.</div>
  <div class="content"><p>прикольно некоторые аспекты XMLHTTPRequest объекта понял</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6049"></a>
<div class="comment">
    <div class="submitted">Опубликовано procentych (не зарегистрирован) в 27.12.2009 в 06:53.</div>
  <div class="content"><p>Два года прошло, а статья актуальна как никогда.<br />
Большое спасибо!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6050"></a>
<div class="comment">
    <div class="submitted">Опубликовано Windheart (не зарегистрирован) в 04.01.2010 в 12:21.</div>
  <div class="content"><p>Спасибо огромное! Отличная, нужная вещь!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6055"></a>
<div class="comment">
    <div class="submitted">Опубликовано <a href="http://andrey.sorvin.ru">Андрей Сорвин</a> (не зарегистрирован) в 24.01.2010 в 08:38.</div>
  <div class="content"><p>Замечательный сайт, всё так подробно расписано про XMLHTTPRequest.<br />
Спасибо вам!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6062"></a>
<div class="comment">
    <div class="submitted">Опубликовано DMH (не зарегистрирован) в 24.02.2010 в 06:40.</div>
  <div class="content"><p>Кто-нибудь сталкивался с несколькими XHR на одной странице?<br />
Имеется первый XHR, который загружается при onload html-страницы, обращается к первой серверной странице, на которой указан sleep (несколько секунд). Также имеется второй XHR, который при нажатии на кнопку отправляет данные пользователя на вторую серверную страницу, на которой нет никаких sleep. Так вот самое удивительное, что данные с обоих страниц приходят одновременно в две разные onreadystatechange-функции, т.е. второй XHR, который должен отработать мгновенно, ждёт пока не выполнится sleep из первого XHR. Возможно ошибка в коде или на сервере (всё написано вручную, нет никаких библиотек, asp.net + iis6), иначе несовсем ясно, как два независимых XHR зависят друг от друга. Вобщем кто сталкивался, напишите. Если у вас работает, значит буду искать ошибку у себя.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6065"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 03.03.2010 в 00:38.</div>
  <div class="content"><p>Кто-нибудь знает как сделать, чтобы Опера <em>кешировала</em> GET-запрос?<br />
Подробнее: <a>http://www.karapuz.by/media/js/ajax-GET-caching-test.html</a></p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6068"></a>
<div class="comment">
    <div class="submitted">Опубликовано Гость (не зарегистрирован) в 10.03.2010 в 04:03.</div>
  <div class="content"><p>увы меня статья не порадовала, интересовал способ отправки файлов на сервер с использованием объекта XMLHttpRequest<br />
сыка автора на "изучите заголовки" мне нафик не нужна, заголовки проблем не вызывают, вопрос как получить в коде JS "сам файл", этот вопрос был кстати в коментариях, а вот ответа небыло, зато много оценок и восторгов автора по поводу фреймворков... но это мне тоже без нужды...</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6089"></a>
<div class="comment">
    <div class="submitted">Опубликовано Прохожик (не зарегистрирован) в 07.06.2010 в 15:32.</div>
  <div class="content"><p>Спасибо за сайт! Долго была проблема с кодировкой при передачи кириллицы в запросах GET. Здесь впервые нашел ответ - метод setRequestHeader. Суть проблемы понимал, но информации о функции нашлась здесь.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6095"></a>
<div class="comment">
    <div class="submitted">Опубликовано Sergey Grigorjev (не зарегистрирован) в 17.06.2010 в 17:32.</div>
  <div class="content"><p>Отличный справочник! Все разложено по полочкам и в одном месте. Когда-то  в свое время искал все эти куски по всему инету! Спасибо!!!!</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
<a id="comment-6108"></a>
<div class="comment">
    <div class="submitted">Опубликовано Андрей Стельмах (не зарегистрирован) в 13.07.2010 в 11:30.</div>
  <div class="content"><p>Так расставлять фигурные скобки нельзя.</p>
<p>закрывающая всегда должна быть под соответствующей ей открывающей, в Вашем случае необходимо все открывающие перемещать на новую строку со смещением влево.</p>
</div>
  <!-- BEGIN: links -->
  <div class="links">&raquo; </div>
  <!-- END: links -->
</div>
</div>            <!-- end main content -->

      </div><!-- main -->
    </td>
      </tr>
</table>

<table id="footer-menu" summary="Navigation elements." border="0" cellpadding="0" cellspacing="0" width="100%">
  <tr>
    <td align="center" valign="middle">
          <ul class="links primary-links"><li class="first menu-1-1-2"><a href="http://xmlhttprequest.ru" class="menu-1-1-2">Главная</a></li>
<li class="menu-1-2-2"><a href="/w3c" class="menu-1-2-2">Спецификация W3C</a></li>
<li class="menu-1-3-2"><a href="http://forum.javascript.ru" class="menu-1-3-2">Форум</a></li>
<li class="last menu-1-4-2"><a href="http://javascript.ru" class="menu-1-4-2">Другие статьи по javascript</a></li>
</ul>            </td>
  </tr>
</table>

<div id="footer-message">
    <p>
</p>
</div>
<script type="text/javascript" src="http://www.google-analytics.com/urchin.js"></script>
<script type="text/javascript">
_uacct = "UA-2056213-7";urchinTracker();
</script>
<script type="text/javascript" src="/modules/google_analytics/downloadtracker.js"></script>
</body>
</html>
