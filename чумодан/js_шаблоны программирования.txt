ПРИЁМЫ ОПТИМИЗАЦИИ ПРОИЗВОДИТЕЛЬНОСТИ ИЗ ВНИЖКИ Николас Закас - JavaScript. Оптимизация производительности - 2012
1. чем глубже в цепочки видимости переменная, тем больше времени тратится на её чтение
2. with и catch  увеличиваею цепочку видимости. поэтому желательно в catch помещать только вызывающую функцию
3. если в теле функции происходит обращение к свойству другого объекта более 1 раза(например document.somvar.color), то желательно сохранить его в локальную переменную
4. доступ к элементам DOM нужно сократить до минимума. а так же любые изменения
5. коллекции элементов живые. поэтому в циклах их нужно использовать осторожно
6. при частых обращениях к элементам коллекции нужно сохранять их в локальных переменных
7. для фильтрации элементов лучше использовать специальные методы. например такие которые не учитывают текстовые узлы
8. попытка получить информацию о расположении элементов вызывает принудительную перерисовку(очистку буфера). поэтому желательно количество таких операций сократить и вызовы сгруппировать и поместить ближе к концу кода
9. cssText += уменьшает количество перерисовок
10. при изменении части страницы(например анимация slideDown) можно перед началом процесса позиционировать элемент абсолютно, произвести анимацию, затем избавиться от абсолютного позиционирования
11. обработчики едят память. поэтому чем их меньше, тем лучше. желательно использовать делегирования событий
12. изменения DOM лучше накапливать например в elementDocument и применять в конце процедуры все сразу
13. так же можно перед началом изменения отключить видимость(display), а в конце изменений включить её
14. цикл for самый быстрый. циклы, перебирающий свойства объектов медленнее
15. длину цикла желательно сохранить в локальную переменную чтобы не читать её при каждом проходе цикла
16. если позволяют условия задачи, то лучше обратить цикл, тем самым исключив лишнюю проверку for(var i = dfg.length; i--){}
17. количество итераций можно уменьшить устройством даффа. если количество итераций > 1000
18. при выборе более 2 дискретных значений лучше использовать switch вместо if-else
19. в if-else более вероятное значение лучше ставить ближе к началу
20. так же можно создавать дополнительные уровни вложености для уменьшения количества проверок
21. если каждому ключу соответсвует определённое значение то лучше использоватьпоисковой таблицы. при этом нет необходимости вычислять значения условных выражений. 
	//определить массив результатов
	var res = [r1, r2, r3];
	//вернуть результат
	return res[value]
	
ПО КНИЖКЕ Стоян Стефанов - JavaScript. Шаблоны (O'REILLY) - 2011	
1. при конструировании объекта необходимо соблюдать принцип минимально необходимых полномочий. то есть отдавать только необходимую информацию.
	function GadgetO { 
	// частный член 
	var specs = { 
		screen_width: 320, 
		screen_height: 480, 
		color: "white" 
	}; 
	// общедоступная функция 
	this.getSpecs = function () { 
		return specs; 
	}; 
	в данном случае возвращается ссылка на объект, а не конкретное свойство. поэтому есть возможность изменить свойство из вне	
	
2. для экономии ресурсов частные члены можно создавать не в конструкторе, а в прототипе	

ПРОСТО ПРИЁМЫ
1. некоторая функция вызывает себя через интервалы времени. интервалы реализованы при помощи setTimeout. наличие условие выхода обязательно
	var i = 0;
	function updateProgress() {
		$("#progressbar").progressbar({
				value: i++
			});
		if (i <= 100){
			setTimeout(updateProgress, 100);
		}		
	}
	updateProgress();

2. callback. вызывается функция и одним из аргументов передаётся другая функция. таким образом обеспечивается её выполнение. например при выходе. или её применение к другим переданным аргументам	