<!DOCTYPE html>
<!-- saved from url=(0065)http://webo.in/articles/habrahabr/15-yahoo-best-practices/#minify -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>Способы ускорения загрузки вашего сайта | webo.in</title><meta charset="windows-1251"><link rel="stylesheet" href="http://webo.in/i/v2/w.wo1.css"><!--[if lt IE 8]><link rel="stylesheet" href="/i/v2/wi.wo1.css"><![endif]--><link rel="icon" href="http://webo.in/favicon.ico" type="image/x-icon"><link rel="alternate" type="application/rss+xml" href="http://webo.in/rss20.xml"><meta name="description" content="Методы уменьшения времени загрузки страницы и загрузки сайта у конечного пользователя. Проверка сайта и проверка скорости. Оптимизация времени загрузки сайта"></head><body class="wi-page"><div class="wi-header"><div class="wi-restrictor"><div class="wi-logo"><a href="http://webo.in/"><img width="183" height="52" title="Знаем все об ускорении сайтов" alt="webo.in" src="./Способы ускорения загрузки вашего сайта   webo.in_files/logo-header.png"></a></div><div class="wi-menu-top"><a href="http://webo.in/about/" class="wi-menu-top-item item-1 ">О проекте</a><a href="http://www.webogroup.com/ru/corporate/test-speed/?utm_source=webo.in&utm_medium=internal&utm_campaign=webo.in.top&url=www.webogroup.com" class="wi-menu-top-item item-2">Проверка скорости</a><a href="http://webo.in/articles/" class="wi-menu-top-item item-3 ">Статьи</a></div><div class="wi-registration"><a href="http://webo.in/my/register/" class="wi-menu-top-item2">Регистрация</a><a href="http://webo.in/my/" class="wi-menu-top-item2">Личный кабинет</a></div></div></div><div class="wi-content"><div class="wi-restrictor"><div class="wi-sidebar"><!--form action="/search/" method="get" accept-charset="utf-8"><p><input name="q" size="20"><input type="submit" value="Поиск" class="submit"></p></form--><p><a style="display: block; width: 230px; height: 300px; background: url(http://webo.in/i/webo.site.speedup.ru.png) no-repeat; text-indent: -999em;" href="http://www.webogroup.com/ru/corporate/site-speedup/?utm_source=webo.in&utm_medium=internal&utm_campaign=webo.in.banner" title="Ускорение сайта в 2,5 раза за 2 минуты">Ускорение сайта «под ключ»</a></p><p><a href="http://textstyle.ru/?webo" rel="nofollow"><img src="./Способы ускорения загрузки вашего сайта   webo.in_files/textstyle.webo2.jpg" alt="Textstyle" title="Дизайн текста. Продающий копирайтинг. Увеличение продаж без увеличения расходов на рекламу" width="240" height="400"></a></p><ul><li><a href="http://www.webogroup.com/ru/corporate/test-speed/?utm_source=webo.in&utm_medium=internal&utm_campaign=webo.in.all&url=www.webogroup.com">Проверка скорости сайта</a></li><li><a href="http://www.webogroup.com/ru/corporate/webo-site-speedup/?utm_source=webo.in&utm_medium=internal&utm_campaign=webo.in.all">Ускорение сайта «под ключ»</a></li><li><a href="http://www.webogroup.com/ru/home/site-speedup/?utm_source=webo.in&utm_medium=internal&utm_campaign=webo.in.all">WEBO Site SpeedUp</a></li></ul><h3><a href="http://speedupyourwebsite.ru/"><b></b><i></i><em></em><q></q>Книги по оптимизации</a></h3><ul><li><a href="http://speedupyourwebsite.ru/books/speed-up-your-website/">«Разгони свой сайт»</a></li><li><a href="http://speedupyourwebsite.ru/books/reactive-websites/">«Реактивные веб-сайты»</a></li></ul><h3><a href="http://yass.webo.in/"><b></b><i></i><em></em><q></q>Yet Another cSS selector</a></h3><ul><li><a href="http://yass.webo.in/">Самая быстрая библиотека для выбора элементов по CSS-селектору</a></li></ul><h3><span><b></b><i></i><em></em><q></q>Ссылки по теме</span></h3><ul><li><a href="http://webo.in/articles/habrahabr/99-web-optimizer-installation-0.5/">Web Optimizer для автоматизации клиентской оптимизации</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/">Способы ускорения загрузки Вашего сайта</a></li><li><a href="http://webo.in/articles/habrahabr/16-optimization-page-load-time/">Анализируем загрузку веб-страницы</a></li><li><a href="http://webo.in/articles/habrahabr/03-presentation-layer-performance-tuning/">Оптимизируем загрузку веб-страницы</a></li></ul><h3><span><b></b><i></i><em></em><q></q>Техника CSS sprites</span></h3><ul><li><a href="http://webo.in/articles/habrahabr/08-all-about-css-sprites/">CSS Sprites: все, что вы знали, но боялись спросить</a></li><li><a href="http://sprites.in/">Auto CSS Sprites</a></li><li><a href="http://webo.in/articles/habrahabr/29-all-about-data-url-images/">Картинки в теле страницы с помощью data:URL</a></li><li><a href="http://duris.ru/">DURIS.ru — data:URL Sprites</a></li></ul><h3><span><b></b><i></i><em></em><q></q>Приемы для JavaScript</span></h3><ul><li><a href="http://javascript.ru/" rel="nofollow">javascript.ru — самоучитель, форум, информация</a></li><li><a href="http://webo.in/articles/habrahabr/23-high-performance-ajax-applications/">Высокопроизводительные AJAX-приложения</a></li><li><a href="http://webo.in/articles/habrahabr/11-minifing-javascript/">Javascript: жать или не жать?</a></li><li><a href="http://webo.in/articles/habrahabr/05-delayed-loading/">Практический JS: «отложенная» загрузка</a></li></ul><h3><span><b></b><i></i><em></em><q></q>Хитрости для CSS</span></h3><ul><li><a href="http://webo.in/articles/habrahabr/14-minifing-css/">CSS: все о сжатии</a></li><li><a href="http://webo.in/articles/habrahabr/07-gzip-all/">Практический CSS/JS: архивируем все!</a></li><li><a href="http://webo.in/articles/habrahabr/19-css-efficiency-tests/">Разгоняем CSS-селекторы: стоит ли?</a></li></ul><h3><a href="http://webo.in/cloud/"><b></b><i></i><em></em><q></q>Облако сайтов</a></h3></div><div class="wi-article"><div class="i y"><span></span><i></i><b></b><p><a href="http://webo.in/articles/" rel="directory" class="current">Статьи</a><b> </b></p><div><strong>Перевод:</strong> Павел Димитриев</div><div>Опубликована: 14 января 2008, <a href="http://developer.yahoo.com/performance/rules.html" lang="en" rel="nofollow">http://developer.yahoo.com/performance/rules.html</a></div></div><div class="tab active x"><h2>Способы ускорения загрузки вашего сайта</h2><p><strong>Автор статьи</strong>: Steve Souders, Yahoo! Developer Network, Yahoo! Inc. 2008</p><p><strong>Другие версии</strong>: <a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/yahoo-best-practices.pdf">PDF</a> и <a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/yahoo-best-practices.txt">TXT</a></p><p><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#intro">Важность производительности фронтенда</a></p><ol><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#http-req">Уменьшите количество HTTP-запросов</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#cdn">Используйте CDN</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#expires">Используйте HTTP-заголовок Expires</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#gzip">Сжимайте компоненты страницы</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#css">Помещайте CSS в начале страницы</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#javascript">Помещайте скрипты в конец</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#expressions">Избегайте CSS-выражений (expressions)</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#external">Выносите javascript и CSS во внешние файлы</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#dns-req">Уменьшайте количество DNS-запросов</a></li><li><a href="./Способы ускорения загрузки вашего сайта   webo.in_files/Способы ускорения загрузки вашего сайта   webo.in.htm">Минимизируйте Javascript</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#redirects">Избегайте редиректов</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#duplicate-scripts">Уберите повторяющиеся скрипты</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#etags">Настройте ETag'и</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#ajax">Делайте AJAX кэшируемым</a></li></ol><h3 id="intro">Важность производительности фронтенда</h3><p>В 2004-м году я организовал группу Исключительной Производительности в Yahoo!. Мы являемся небольшой группой разработчиков, чьей целью является улучшение производительности продуктов Yahoo!. Проработав большую часть своей карьеры back-end инженером, я постепенно пришел к этому: я исследовал различные аспекты веб-разработки для выявления наилучших способов увеличения производительности. Т.к. нашей целью является улучшение восприятия продукта пользователем, я измерил <a href="http://webo.in/">время загрузки</a> различных элементов страницы. И вот что я увидел:</p><p><img src="./Способы ускорения загрузки вашего сайта   webo.in_files/graph.png" alt="Скорость загрузки сайта" title="Скорость загрузки сайта" width="566" height="631"></p><p>На картинке первый ряд, обозначенный «html» — это начальный запрос HTML-документа. В данном случае на его получение было потрачено только 5% всего времени загрузки страницы. Практически для всех сайтов вы увидите то же самое. К примеру, все, кроме одного, сайты, вошедшие в десятку популярных сайтов в Штатах, тратят менее 20% на загрузку HTML. Остальные 80 с лишним процентов времени загрузки тратятся на загрузку того, что указано в самом HTML — собственно, фронтэнда. Вот почему ключем создания быстрых сайтов является улучшение производительности фронтэнда.</p><p>Существует три причины, почему стоит начать с производительности фронтэнда:</p><ol><li>От улучшения фронтэнда больше всего толку: урезав его на половину, мы добъемся 40-процентного (и выше) уменьшения времени загрузки страницы, тогда как уменьшение бекэнда на половину даст в лучшем случае 10% прироста скорости.</li><li><a href="http://webo.in/">Оптимизация фронтэнда</a> обычно требует меньше времени и усилий, чем <a href="http://webo.in/speed/complex/">оптимизация бэкэнда</a> (редизайн архитектуры приложения и кода, поиск и <a href="http://webo.in/speed/javascript/">оптимизация критичных участков</a> кода, добавления или изменение аппаратного обеспечения, баз данных и пр.)</li><li>Оптимизация фронтенда зарекомендовала себя: более 50 групп разработчиков в Yahoo! уменьшили время отклика своих приложений на 25% и выше просто следуя нашим советам.</li></ol><p>Наше золотое правило: <em>в первую очередь оптимизируйте фронтэнд — вот где тратится от 80% времени загрузки страницы</em>.</p><h3 id="http-req">1: Уменьшите количество HTTP-запросов</h3><p>80% времени загрузки тратится фронтэндом. Большая часть времени уходит на загрузку компонентов страницы: картинок, таблиц стилей, скриптов, flash. Уменьшение количества этих компонентов уменьшает количество запросов к серверу, необходимых до того, как клиентское приложение может отрендерить страницу. Это — ключ к созданию быстрых страниц.</p><p>Первый путь уменьшить количество компонентов страницы — упростить ее дизайн. А есть ли способ сохранить внешний вид, при этом уменьшив время загрузки? Ниже следует несколько приемов, позволяющих добиться уменьшения количества запросов к серверу, сохраняя функциональность и внешний вид.</p><p><a href="http://www.w3.org/TR/html401/struct/objects.html#h-13.6" lang="en" rel="nofollow">Image Map</a>'ы объединяют несколько картинок в одну большую. Общий объем такой картинки примерно равен сумме объемов маленьких картинок, но уменьшение количества запросов к серверу сокращает общее время загрузки страницы. Image Map будет работать, если картинки на странице находятся рядом друг с другом, например в случае полосы навигации. Определение координат для Image Map'ов — занятие довольно утомительное и зачастую приводит к ошибкам (<em>прим. пер.: вообще-то для этого есть специальный софт, однако ничего не могу сказать про качество его работы</em>).</p><p><a href="http://alistapart.com/articles/sprites" lang="en" rel="nofollow">CSS-спрайты</a> являются предпочтительным методом сокращения количества запросов на сервер. Объедините все картинки веб-страницы в одну большую картинку и используйте CSS-свойства <code>background-image</code> и <code>background-position</code> для отображения нужного участка картинки.</p><p><strong>Inline-картинки</strong> используют <a href="http://tools.ietf.org/html/rfc2397" lang="en" rel="nofollow">URL-схему <code>data:</code></a> для встраивания картинки в саму страницу. Это, однако, увеличит размер HTML-документа. Встраивайте inline-картинки в ваши (<a href="http://webo.in/articles/all/http-caching/">кешированные</a>) таблицы стилей — и вы добьетесь уменьшения запросов к серверу, а размер HTML останется прежним.</p><p><strong>Объединение файлов</strong> также уменьшает количество запросов на сервер. Объедините несколько скриптов в один скрипт, а несколько таблиц стилей — в одну таблицу. Это простая идея, однако она не нашла широкого распространения. Top-10 сайтов по штатам имеют в среднем 7 скриптов и 2 таблицы стилей. Объединение файлов наиболее применимо, когда набор подгружаемых скриптов и CSS отличается от страницы к странице, и этот прием уменьшает общее время загрузки.</p><p>Начните оптимизацию своей страницы с уменьшения количества HTTP-запросов. Это самый важный совет для ускорения загрузки страницы у посетителей, которые заходят к вам в первый раз. Как сказано в <a href="http://yuiblog.com/blog/2007/01/04/performance-research-part-2/" lang="en" rel="nofollow">блоге Tenni Theurer'а</a>: «40-60% посетителей приходят на сайт с пустым кешем». Сделать страницу более быстрой для загрузки этими пользователями — вот ключ к улучшению восприятия страницы пользователями.</p><h3 id="cdn">2: Используйте CDN</h3><p>На <a href="http://webo.in/speed/">скорость загрузки страницы</a> сильно влияет и то, насколько далеко пользователь находится от вашего сервера. Размещение вашего контента между несколькими серверами, разнесенными географически, сделает загрузку сайта быстрее с точки зрения пользователя. Но с чего бы начать?</p><p>В качестве первого шага к построению системы с географически распределенным контентом не пытайтесь изменить архитектуру вашего веб-приложения для работы с распределенной архитектурой. В зависимости от приложения, изменение архитектуры может повлечь за собой сложные изменения, такие как синхронизация состояния сессий или репликацию транзакций баз данных между географически разнесенными серверами. Вы можете провалить все попытки сокращения расстояния между серверами и пользователями этими архитектурными изменениями.</p><p>Помните, что 80-90% времени загрузки страницы уходит на загрузку ее компонентов: картинок, CSS, скриптов, flash и т.д. Это — <em>Золотое правило производительности</em>, как сказано в статье <a href="http://developer.yahoo.net/blog/archives/2007/03/high_performanc.html" lang="en" rel="nofollow">Важность производительности фронтэнда</a> Steve'a Souders'а. Вместо того, чтобы заниматься изменением архитектуры своего приложения, сначала стоит разнести статический контент. Это не только позволяет добиться значительного ускорения загрузки страницы, но также легко реализуется благодаря CDN.</p><p>CDN (Content Delivery Network) — это множество веб-серверов, разнесенных географически для достижения максимальной скорости отдачи контента клиенту. Сервер, который непосредственно будет отдавать контент пользователю, выбирается на основании некоторых показателей. Например, выбирается сервер с наименьшим числом промежуточных хопов до него либо с наименьшим временем отклика.</p><p>Некоторые крупные интернет-компании владеют своими сетями CDN, однако гораздо дешевле использовать уже готовые решения, такие как <a href="http://www.akamai.com/" lang="en" rel="nofollow">Akamai Technologies</a>, <a href="http://www.mirror-image.com/" lang="en" rel="nofollow">Mirror Image Internet</a> либо <a href="http://www.limelightnetworks.com/" lang="en" rel="nofollow">Limelight Networks</a>. Для стартапов или личных веб-сайтов стоимость услуг сетей CDN может оказаться непомерно высокой, однако по мере того, как ваша аудитория увеличивается и становится все более удаленной от вас, CDN просто необходимы для достижения быстрого времени отклика вашей страницы. В Yahoo! те, кто перенес свой статический контент с серверов веб-приложений в CDN, добились 20-процентного прироста производительности (и выше). Использование CDN потребует лишь незначительных изменений вашего кода, но принесет огромное увеличение производительности ваших веб-приложений.</p><h3 id="expires">3: Используйте HTTP-заголовок Expires</h3><p>Дизайн страниц становится все сложней и сложней, что подразумевает использование большего количества скриптов, CSS, картинок и флеша. Посетителю, пришедшему к вам на страницу в первый раз, возможно потребуется сделать несколько запросов на веб-сервер, однако используя HTTP-заголовок Expires, вы сделаете компоненты страницы кешируемыми. Это предупредит ненужные запросы при последовательном просмотре нескольких страниц. Заголовок Expires чаще всего используется с картинками, однако его следует использовать со <em>всеми</em> компоненатами страницы, включая скрипты, флеш, CSS.</p><p>Браузеры (и прокси) используют кеш чтобы уменьшить количество запросов к серверу (и их объем) и таким образом загружая страницу быстрее. Веб-сервер использует заголовок Expires, чтобы указать клиентскому приложению, как долго можно хранить объект в кеше. Вот пример заголовка, который указывает, что объект не изменится до 15 апреля 2010 года:</p><blockquote><pre>Expires: Thu, 15 Apr 2010 20:00:00 GMT</pre></blockquote><p>Если ваш веб-сервер — Apache, используйте директиву ExpiresDefault, чтобы установить заголовок Expires относительно текущего момента. Следующий пример устанавливает время Expires на 10 лет вперед от момента HTTP-запроса:</p><blockquote><pre>ExpiresDefault "access plus 10 years"</pre></blockquote><p>Однако помните, если вы устанавливаете Expires в далекое будущее, вам необходимо изменять названиe файла компонента страницы каждый раз, когда вы будете менять его содержимое. В Yahoo! это является частью процесса разработки: мы используем версию в названии файла, к примеру <code>yahoo_2.0.6.js</code>.</p><p>Установка заголовка Expires в далекое будущее влияет на отображение страницы только для пользователей, которые заходят к вам не впервые. Для тех же, кто зашел на вашу страницу в первый раз, либо кеш его браузера пуст, этот заголовок не сыграет никакой роли. Почувствует ли пользователь сильную разницу в загрузке страницы из-за этого улучшения или нет, зависит от того, насколько часто он заходит к вам с «полным кешем» (кеш уже содержит все компоненты страницы). Мы <a href="http://yuiblog.com/blog/2007/01/04/performance-research-part-2/" lang="en" rel="nofollow">исследовали это в Yahoo!</a> и оказалось, что 75-80% посетителей уже имеют «полный кеш». Устанавливая заголовок Expires в далекое будущее, вы увеличиваете долю кешируемых компонентов на странице, которые используются повторно (из кеша) при загрузке следующей страницы вашего сайта без пересылки единого байта через интернет.</p><h3 id="gzip">4: Сжимайте компоненты страницы</h3><p>Время, необходимое для пересылки через сеть HTTP-запроса и ответа на него, может быть сильно уменьшено решениями разработчиков фронтэнда. Да, конечно, скорость интернета у конечного пользователя, его интернет-провайдер, близость к точкам обмена трафиком — все это вне контроля разработчиков сайта. Но есть также и другие факторы, влияющие на время загрузки страницы. Сжатие помогает уменьшить время загрузки HTTP-ответа, уменьшая его объем.</p><p>Начиная с версии протокола HTTP/1.1, веб-клиенты указывают, какие типы сжатия они поддерживают, устанавливая заголовок Accept-Encoding в HTTP-запросе.</p><blockquote><pre>Accept-Encoding: gzip, deflate</pre></blockquote><p>Если веб-сервер видит такой заголовок в запросе, он может применить сжатие ответа одним из методов, перечисленных клиентом. При выдаче ответа посредством заголовка Content-Encoding сервер уведомляет клиента о том, каким методом сжимался ответ.</p><blockquote><pre>Content-Encoding: gzip</pre></blockquote><p>На данный момент <a href="http://webo.in/articles/all/mod-gzip-minify-on-fly/">gzip</a> является наиболее популярным и эффективным алгоритмом сжатия. Он был разработан проектом GNU и стандартизован в рамках <a href="http://www.ietf.org/rfc/rfc1952.txt" lang="en" rel="nofollow">RFC 1952</a>. Единственный алгоритм, который вы можете встретить где-нибудь, кроме gzip — это deflate, однако он не так эффективен и менее популярен.</p><p>В среднем сжатие gzip уменьшает размер HTTP-ответа на 70%. Приблизительно 90% используемых сегодня браузеров указывают, что они поддерживают сжатие gzip. Если вы используете Apache, модуль, отвечающий за сжатие, отличается в разных версиях: Apache 1.3 использует <a href="http://sourceforge.net/projects/mod-gzip/" lang="en" rel="nofollow">mod_gzip</a>, а Apache 2.x — <a href="http://httpd.apache.org/docs/2.0/mod/mod_deflate.html" lang="en" rel="nofollow">mod_deflate</a>.</p><p>Существуют некоторые несоответствия, когда браузеры (прокси) получают в ответ не то, что ожидают. К счастью, такие случаи встречаются все реже, так как использование старого софта постепенно сходит на нет. Модули Apache выручат вас, автоматически добавляя специальные Vary-заголовки для обхода таких случаев.</p> <p>Сервер определяет, какие данные нужно сжимать, основываясь на типе файла, но обычно он сильно ограничен в этом выборе. Большинство сайтов сжимают свой HTML. Также стоит сжимать скрипты и CSS, однако многие не используют эту возможность. Фактически, следовало бы сжимать весь контент, который отдается клиенту текстом (в т.ч. XML и JSON). Не стоит жать картинки и PDF, так как они уже сжаты. Попытка сжать их не только отнимет процессорное время, но даже может увеличить размер такого файла.</p><p>Сжатие всего, что жмется, — самый простой способ уменьшить страницу в объеме и ускорить ее загрузку к пользователю.</p><h3 id="css">5: Помещайте CSS в начале страницы</h3><p>Исследуя производительность в Yahoo!, мы пришли к выводу, что помещение CSS в HEAD страницы ускоряет ее загрузку, т.к. позволяет отрендерить ее постепенно.</p><p>Разработчики, которые заботятся о производительности своей страницы, всегда хотят, чтобы она могла быть отрендерена постепенно; мы хотим, чтобы браузер мог отобразить любой контент сразу же, как он у него появится. Это особенно важно для страниц, на которых много контента и для пользователей с медленным подключением. Важность визуального оповещения пользователя о текущем состоянии загрузки страницы каким-нибудь индикатором прогресса детально изучена и <a href="http://www.useit.com/papers/responsetime.html" lang="en" rel="nofollow">документирована</a>. В нашем случае в роли индикатора прогресса выступает сама HTML-страница. Когда браузер загружает страницу постепенно — сначала заголовок, потом навигацию, лого наверху и т.д. — все это служит отличным индикатором загрузки для пользователя, который ожидает страницу. Также это улучшает общее впечатление.</p><p>Размещение CSS в конце страницы не позволяет начать постепенный рендеринг многим браузерам, в числе которых Internet Explorer. Браузер не начинает рендерить страницу, чтобы не пришлось перерисовывать элементы, у которых во время загрузки изменится стиль. Firefox начинает сразу отрисовывать страницу, в процессе загрузки, возможно, перерисовывая некоторые элементы, но это является причиной <a href="http://weblogs.mozillazine.org/hyatt/archives/2004_05.html#005496" lang="en" rel="nofollow">появления нестилизованного контента</a> (FOUC — Flash Of Unstyled Content).</p><p><a href="http://www.w3.org/TR/html4/struct/links.html#h-12.3" rel="nofollow" lang="en">Спецификация HTML4</a> устанавливает, что таблицы стилей должны быть включены в HEAD-секцию документа: «В отличие от A, [LINK] может появляться только в секции HEAD, зато там [LINK] может встречаться сколько угодно раз». Ни одна из альтернатив — белого экрана и показа нестилизованного контента — не стоит риска. Оптимальным решением является следование спецификации и включение CSS в HEAD-секцию документа.</p><h3 id="javascript">6: Помещайте скрипты в конец</h3><p>Предыдущее правило рассказало нам, как размещение таблиц CSS в конце страницы <a href="http://webo.in/articles/habrahabr/01-how-javascript-slow-down-web/">тормозит</a> отрисовку страницы браузером и как помещение CSS в HEAD решает эту проблему. Скрипты (внешние .js-файлы) создают похожую проблему, но решается она ровным счетом наоборот: скрипты следует переносить в самый низ страницы, как можно ближе к концу. Делая так, мы позволяем браузеру рендерить страницу постепенно и <a href="http://webo.in/articles/habrahabr/16-optimization-page-load-time/">одновременно распараллеливаем загрузку</a>.</p><p>В случае с CSS, постепенный рендеринг не начинается, пока не подгрузятся все таблицы стилей. Вот почему лучше включать их в секцию HEAD, чтобы они грузились в первую очередь и не тормозили рендеринг. В случае скриптов, постепенный рендеринг не начинается для всего контента <em>ниже</em> скрипта. Таким образом, нам выгоднее размещать скрипты как можно ниже.</p><p>Вторая проблема, порождаемая скриптами — они блокируют параллельную загрузку. <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec8.html#sec8.1.4" lang="en" rel="nofollow">Спецификация HTTP/1.1</a> советует, чтобы браузеры параллельно загружали не более 2-х компонентов веб-страницы с одного хоста. Таким образом, если картинки для вашего сайта располагаются на разных хостах, вы получите более 2-х параллельных загрузок (я заставил Internet Explorer загружать более 100 картинок параллельно). А когда загружается скрипт, браузер не будет начинать никаких других загрузок, даже с других хостов.</p><p>Но в некоторых ситуациях совсем не просто перенести скрипты в конец страницы. Например, если скрипт использует <code>document.write</code> для вставки части контента на страницу, такой скрипт не получится перенести вниз. Во многих случаях есть способы обхода таких ситуаций.</p><p>Альтернативным решением, которое часто используется, является отложенное выполнение скриптов. Атрибут DEFER указывает, что скрипт не содержит document.write и, видя его, браузер продолжает рендеринг страницы. К сожалению, Firefox не поддерживает атрибут DEFER. В Internet Explorer выполнение скрипта можно задержать, но не настолько, насколько хотелось бы. Если выполнение скрипта можно отложить, значит его можно перенести в конец страницы. Это сделает ее загрузку быстрее.</p><h3 id="expressions">7: Избегайте CSS-выражений (<a href="http://webo.in/articles/habrahabr/10-css-expressions-optimization/">expressions</a>)</h3><p>CSS-выражения являются мощным (и опасным) способом динамического задания стилей. Они поддерживаются Internet Explorer'ом начиная с <a href="http://msdn.microsoft.com/workshop/author/dhtml/overview/recalc.asp" lang="en" rel="nofollow">Internet Explorer 5</a>. К примеру: вот так можно устанавливать разный фон в зависимости от текущего времени:</p><blockquote><pre>background-color: expression( (new.Date()).getHours()%2 ? "#B8D4FF" : "#F08A00" );</pre></blockquote><p>Как видно из примера, метод <code>expression</code> принимает javascript-выражение. Свойство CSS устанавливается равным результату вычисления этого выражения. Метод <code>expression</code> игнорируется остальными браузерами, поэтому он полезен для создания кросс-браузерного кода (для создания одного и того же поведения страницы в разных браузерах).</p><p>Проблема с этими выражениями в том, что они вычисляются гораздо чаще, чем многие могли бы ожидать. Они вычисляются не только во время рендеринга страницы и изменения размеров окна, но также при скроллинге и даже когда пользователь просто водит мышкой над страницей. Это несложно отследить, достаточно добавить счетчик в выражение. Обычное движение мышкой над страницей запросто может вызвать вычисление выражения более 10000 раз.</p><p>Единственный способ избежать огромного числа вычисления CSS-выражений — использование одноразовых выражений, когда после проведения всех необходимых вычислений, они устанавливают свойство CSS-стиля к какому-то конечному статическому значению, заменяя им CSS-выражение. Если вам необходимо динамически изменять свойство CSS-стиля по мере пребывания пользователя на странице, вы можете использовать прием с перехватчиками событий (event handlers) в качестве альтернативы. Если же вам обязательно нужно использовать CSS-выражения на странице, помните, что они могут вычисляться тысячи раз и тем самым повлиять на производительность всей страницы.</p><h3 id="external">8: Выносите javascript и CSS во внешние файлы</h3><p>Многие из этих правил по улучшению производительности описывают то, как нужно работать с подключаемыми компонентами (в частности, со скриптами и CSS). Однако прежде чем вы начнете применять эти советы на практике, было бы неплохо, если бы вы поинтересовались более базовым вопросом: а стоит ли вообще подключать .js- и .css-файлы или можно включить весь их код непосредственно в код страницы (inline)?</p><p>Использование подключаемых файлов на практике обычно дает более быстрые страницы, т.к. браузеры кешируют файлы скриптов и CSS. Код javascript и CSS, который встраивается в HTML, загружается каждый раз, когда загружается сам HTML-документ. Это уменьшает количество необходимых HTTP-запросов, но увеличивает объем HTML. С другой стороны, если скрипты и таблицы стилей находятся в отдельных файлах, скэшированных браузером, размер HTML уменьшается, не увеличивая при этом количество HTTP-запросов.</p><p>В таком случае ключевым фактором является частота, с которой кэшируются внешние .js- и .css-файлы относительно количества запросов самого HTML-документа. И хотя этот фактор очень сложно посчитать, его можно приблизительно оценить различными способами. Если ваши пользователи во время одного посещения загружают страницу несколько раз или загружают похожие страницы, которые используют один и тот же код — это лучший случай, чтобы получить все преимущества от вынесения кода в отдельные файлы.</p><p>Многие сайты только на половину удовлетворяют этим условиям. Для таких случаев в целом лучшим решением будет создание внешний файлов скриптов и таблиц стилей. Единственное исключение, которое я видел, когда использование inline-кода дает большее преимущество — это использование его на домашних страницах, таких как главная страница Yahoo! (http://www.yahoo.com/) и My Yahoo! (http://my.yahoo.com/). Для страниц, которые загружаются всего несколько (обычно — один) раз за весь сеанс, выгодней встраивать скрипты и таблицы стилей прямо в HTML-документ, чтобы выиграть в <a href="http://webo.in/">скорости загрузки</a>.</p><p>Для таких главных страниц, которые открываются первыми в последовательности других с этого же сайта, есть прием снижения количества HTTP-запросов за счет включения скриптов и CSS в код страницы, равно как использования всех преимуществ кэширования за счет динамической загрузки внешних файлов после загрузки всей страницы. Следующие страницы будут использовать уже скэшированные файлы.</p><h3 id="dns-req">9: Уменьшайте количество DNS-запросов</h3><p>Система DNS устанавливает соответствие имен хостов их IP-адресам, точно так же, как телефонный справочник позволяет узнать номер человека по его имени. Когда вы набираете www.yahoo.com в адресной строке браузера, преобразователь DNS (DNS-resolver), к которому обратился браузер, возвращает IP-адрес узла. DNS имеет свою цену. Обычно требуется 20-120 миллисекунд, чтобы выполнить DNS-запрос и получить ответ (<em>прим. пер.: в российских реалиях это время обычно выше</em>). Браузер вынужден ожидать завершения DNS-запроса, т.к. до этого момента он еще не может ничего загружать.</p><p>Для повышения быстродействия результаты DNS-запросов кэшируются. Это кэширование может происходить как на специальном сервере интернет-провайдера, так и на компьютере пользователя. Информация DNS сохраняется в системном кэше (в Windows за это отвечает служба «DNS Client Service»). Большинство браузеров имеет свой кэш, не зависящий от системного. Пока браузер хранит DNS-запись в своем кэше, он не обращается к операционной системе для DNS-преорбазования.</p><p>Internet Explorer по умолчанию кэширует результаты DNS-запросов на 30 минут, как указано в переменной реестра <code>DnsCacheTimeout</code>. Firefox кэширует DNS-ответы на 1 минуту, что видно из установки <code>network.dnsCacheExpiration</code> (Fasterfox увеличивает это время до 1 часа).</p><p>Когда клиентский кэш очищается (как системный, так и у браузера), количество DNS-запросов возрастает до количества уникальных имен хостов на странице. А это включает в себя собственно адрес самой страницы, картинок, скриптов, CSS, объектов Flash и т.д. Уменьшение количества уникальных имен хостов уменьшает количество DNS-запросов.</p><p>Уменьшение количества уникальных имен хостов потенциально уменьшает количество параллельных загрузок компонентов страницы. Уменьшение количества DNS-запросов уменьшает время загрузки страницы, но уменьшение количества параллелльных загрузок может увеличить это время. Мой совет — распределить загружаемые компоненты между 2-4 (но не более) уникальными хостами. Это является компромиссом между уменьшением количества DNS-запросов и сохранением неплохой параллельности при загрузке компонентов страницы.</p><h3 id="minify">10: Минимизируйте Javascript</h3><p>Минимизация скрипта — это удаление из кода всех несущественных символов с целью уменьшения объема файла скрипта и ускорения его загрузки. В минимизированном коде удаляются все комментарии и незначащие пробелы, переносы строк, символы табуляции. В случае с Javascript, это уменьшает время загрузки страницы, т.к. размер файла уменьшается. Две самых популярных утилиты для минимизации javascript — <a href="http://crockford.com/javascript/jsmin" lang="en" rel="nofollow">JSMin</a> и <a href="http://developer.yahoo.com/yui/compressor/" lang="en" rel="nofollow">YUI Compressor</a>.</p><p>Обфускация является альтернативным способом сокращения исходного кода. Также, как минимизация, она удаляет пробельные символы и вырезает комментарии, но в дополнение она измененяет сам код. К примеру, во время обфускации имена функций и переменных заменяются на более короткие, что делает код более компактным, но менее читабельным. Обычно этот прием используется для усложнения реверс-инжиниринга программы. Но обфускация помогает также уменьшить код настолько, насколько это не получится сделать одной минимизацией. С выбором средства для обфускации javascript не все так ясно, но я думаю, что самая распространенная утилита для этого — Dojo Compressor (<a href="http://dojotoolkit.org/docs/shrinksafe" lang="en" rel="nofollow">ShrinkSafe</a>).</p><p>Минимизация javascript — безопасный и довольно простой процесс. С другой стороны, обфускация из-за своей сложности может вносить в код баги. Обфускация также требует правки вашего кода для выделения в нем API-функций и других элементов. которые не должны быть изменены. Это также делает более сложной отладку в продакшне. Я никогда не видел, чтобы минимизация кода создавала в нем баги, но вот при обфускации такое случалось. Среди первой десятки американский сайтов при минимизации в среднем достигалось 21% сжатие, тогда как при обфускации — 25%. И хотя обфускация позволяет добиться большего сжатия, я все же рекомендую применять минимизацию кода, так как она не добавит в ваш код ошибок и полученный скрипт проще будет отлаживать.</p><p>В дополнение к минимизации внешних скриптов, <a href="http://webo.in/articles/habrahabr/29-all-about-data-url-images/">встроенные</a> в HTML-код скрипты также могут и должны быть минимизированы. Даже если вы сжимаете скрипты gzip'ом, как описано в <a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#gzip">четвертом правиле</a>, минимизация все равно даст выигрыш от 5% и более. По мере того, как будет увеличиваться ваш javascript-код, будет увеличиваться и процент сжатия от минимизации.</p><h3 id="redirects">11: Избегайте редиректов</h3><p>Редиректы осуществляются посредством отправки клиенту статус-кодов HTTP 301 и 302. Вот пример HTTP-заголовка со статус-кодом 301:</p><blockquote><pre>HTTP/1.1 301 Moved Permanently
Location: http://example.com/newuri
Content-Type: text/html</pre></blockquote><p>Браузер автоматически перенаправляет пользователя на новый адрес, указанный в поле <code>Location</code>. Вся информация, необходимая для редиректа, есть в этих заголовках, тело ответа обычно остается пустым. Результаты редиректов (ни с кодом 301, ни с кодом 302) на практике не кешируется, пока это явно не объявляется заголовком <code>Expires</code> либо <code>Cache-Control</code>. Другими способами перенаправить пользователя является использование мета-тега Refresh и javascript'а, однако, если вам все же необходимо сделать редирект, предпочтительней использование именно статус-кодов HTTP 301 и 302, хотя бы из-за того, что у пользователя будут правильно работать кнопки «Назад» и «Вперед».</p><p>Главое, что нужно помнить при использовании редиректов — это то, что они отнимают время на свое выполнение, а пользователь должен ждать его завершения. Страница даже не может начать рендериться из-за того, что пользователь еще не получил сам HTML-документ и браузер не может начать загрузку остальных компонентов страницы.</p><p>Одним из бесполезных редиректов, которые часто используются (и веб-разработчики не стремятся избегать этого) — когда пользователь забывает ввести завершающий слэш (/) в адресной строке в тех случаях, когда он там должен быть. Например, если вы попробуете открыть <a href="http://astrology.yahoo.com/astrology">http://astrology.yahoo.com/astrology</a>, вам вернется ответ с кодом 301, содержащий редирект на <a href="http://astrology.yahoo.com/astrology/">http://astrology.yahoo.com/astrology/</a> (обратите внимание на завершающий слэш). Это исправляется в Apache использованием <code>Alias</code> или <code>mod_rewrite</code>, или же <code>DirectorySlash</code>, если вы используете перехватчики Apache (Apache handlers).</p><p>Объединение старого и нового сайтов также часто является причиной использования редиректов. Кое-кто объединяет часть старого и нового сайтов и перенаправляет (или не перенаправляет) пользователя, основываясь на каких-то факторах: браузере, типе аккаунта пользователя и т.д. Использование редиректов для объединения двух сайтов является достаточно простым способом и требует минимального программирования. Но использование редиректов в таких ситуациях усложняет поддержку проекта для разработчиков и ухудшает восприятие страницы пользователями. Альтернативой редиректу является использование модулей <code>mod_alias</code> и <code>mod_rewrite</code> в случае, если оба URI находятся в пределах одного сервера. Если же причиной появления редиректов является перенаправление пользователя между разными хостами, как альтернативу можно рассматривать создание DNS-записей типа CNAME (такие записи создают псевдонимы для доменов) в комбинации с <code>Alias</code> или <code>mod_rewrite</code>.</p><h3 id="duplicate-scripts">12: Уберите повторяющиеся скрипты</h3><p>Включение одного скрипта дважды на одну страницу снижает производительность. Это не так редко встречается, как вы могли бы подумать. Два из десяти наиболее посещаемых сайтов в Америке содержит повторяющийся javascript-код. Два главных фактора, которые могут повлиять на возникновение повторяющихся скриптов — количество скриптов на странице и количество разработчиков. Когда это случается, повторение скриптов замедляет работу сайта ненужными HTTP-запросами и вычислениями.</p><p>Повторяющиеся запросы возникают в Internet Explorer'е, но не возникают в Firefox. Internet Explorer дважды загружает один и тот же скрипт, если он включен в страницу два раза и не кэшируется. Но даже если скрипт скэширован, все равно возникает дополнительный HTTP-запрос, когда пользователь перезагружает страницу.</p><p>В дополнение к ненужным HTTP-запросам, тратится время на выполнение кода. Повторное исполнение кода происходит в обоих браузерах, не зависимо от того, был ли скэширован скрипт или нет.</p><p>Единственным способом избежать повторного включения одного и того же скрипта является разработка системы управления скриптами в виде модуля вашей системы шаблонов. Обычным способом включения скрипта в страницу является использование тега <code>SCRIPT</code>:</p><blockquote><pre>&lt;script type="text/javascript" src="menu_1.0.17.js"&gt;&lt;/script&gt;</pre></blockquote><p>Альтернативой в PHP можно считать создание функции <code>insertScript</code>:</p><blockquote><pre>&lt;?php insertScript("menu.js") ?&gt;</pre></blockquote><p>Кроме простого предотвращения включения одного скрипта на страницу дважды, такая функция может выполнять и другие задачи, к примеру, отслеживать зависимости между скриптами, добавлять номер версии в название файла скрипта для поддержки HTTP-заголовков Expires и пр.</p><h3 id="etags">13: Настройте ETag'и</h3><p>ETag'и (Entity Tags — тэги сущностей) — механизм, который используют браузеры и веб-сервера, чтобы определить, является ли объект, находящийся в кэше браузера таким же, как соответствующий объект на сервере (а Entity (сущность) — другое название того, что мы называем компонентами: картинки, скрипты и т.д.). Тэги сущностей были задуманы как механизм для определения актуальности сущности в кэше браузера, что является более гибким подходом, нежели проверка по дате последнего изменения (last-modified). ETag — это строка, которая однозначно идентифицирует конкретную версию компонента. Единственное требование: строка должна быть заключена в двойные кавычки (лапки). Сервер указывает ETag для компонента используя HTTP-заголовок <code>ETag</code>:</p><blockquote><pre>HTTP/1.1 200 OK
Last-Modified: Tue, 12 Dec 2006 03:03:59 GMT
ETag: "10c24bc-4ab-457e1c1f"
Content-Length: 12195</pre></blockquote><p>Позднее, если браузер хочет определить актуальность компонента, он передает заголовок <code>If-None-Match</code> для передачи ETag'а обратно на сервер. Если ETag'и совпадают, ответ от сервера приходит со статус-кодом 304, уменьшая таким образом объем передачи на 12195 байт:</p><blockquote><pre>GET /i/yahoo.gif HTTP/1.1
Host: us.yimg.com
If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMT
If-None-Match: "10c24bc-4ab-457e1c1f"
HTTP/1.1 304 Not Modified</pre></blockquote><p><em>Примечание: включить ETag для Apache можно, например, следующей директивой:</em></p><blockquote><pre>FileETag MTime Size</pre></blockquote><p>Проблема ETag'ов в том, что обычно они используют атрибуты, специфичные в пределах одного сервера. ETag'и не совпадут, если браузер загрузит компонент страницы с одного сервера и попробует проверить его с другим сервером — ситуация очень частая, если вы используете кластер для обработки запросов. По умолчанию и Apache, и IIS включают в ETag такие данные, которые вряд ли дадут положительные результат при проверке на актуальность компонента на разных серверах.</p><p>Apache 1.3 и 2.x генерирует ETag в формате <code>inode-size-timestamp</code>. Даже если один и тот же файл на разных серверах лежит в одной и той же папке, имеет те же права, размер и время, номер его инода будет отличаться от сервера к серверу.</p><p>IIS 5.0 и 6.0 имеют похожий формат ETag'ов: <code>Filetimestamp:ChangeNumber</code>. <code>ChangeNumber</code> — внутренняя переменная IIS для отслеживания изменений в конфигурации самого IIS, и нет гарантии, что эта переменная будет одинакова на всех серверах, обслуживающих веб-сайт.</p><p>В результате ETag'и, которые сгенерирует Apache или IIS для одного и того же файла, будут отличаться на разных серверах. Если ETag'и не будут совпадать, пользователь не будет получать маленького и быстрого ответа с кодом 304 — собственно, зачем ETag'и и разрабатывались; взамен он будет получать стандартный код ответа 200 и далее весь запрошенный компонент. Если ваш сайт находится только на одном сервере, это не будет для вас проблемой. Но если вы используете несколько серверов с Apache или IIS, устанавливающие ETag в соответствии с настройками по-умолчанию, ваши пользователи будут дольше загружать страницы, на серверах будет большая загрузка, нежели могла бы, вы будете тратить больше трафика, а прокси не будут кэшировать ваш контент так, как хотелось бы. Даже если вы установите заголовок <code>Expires</code> в далекое будущее, вам все равно будет приходить условный GET-запрос когда пользователь перезагрузит страницу.</p><p>Если вы не получаете всех преимуществ, которые предоставляет ETag, тогда лучше совсем отключить его. Тэг <code>Last-Modified</code> позволяет проверять актуальность компонента на основании его timestamp'а, а отключение ETag'а позволяет уменьшить заголовки запроса и ответа. <a href="http://support.microsoft.com/?id=922733" lang="en" rel="nofollow">Эта статья из базы знаний Microsoft</a> описывает, как отключить ETag в IIS. Если же вы используете Apache, просто добавьте строку</p><blockquote><pre>FileETag none</pre></blockquote><p>в конфигурационный файл сервера.</p><h3 id="ajax">14: Делайте <a href="http://webo.in/articles/habrahabr/23-high-performance-ajax-applications/">AJAX</a> кэшируемым</h3><p>Меня часто спрашивают, применимы ли эти советы для Web2.0 приложений? Конечно, да! Это правило — первое, появившееся после внедрения Web2.0 приложений в Yahoo!.</p><p>Одно из преимуществ AJAX'а — это то, что он дает моментальный отклик на действие пользователя, т.к. позволяет подгружать данные асинхронно с сервера. Однако при использовании AJAX все еще нет гарантии того, что пользователь не будет бить баклуши в ожидании получения данных с удаленного сервера. Во многих веб-приложениях время ожидания данных пользователем зависит от того, как применяется AJAX. Напрмер, в почтовом веб-клиенте пользователь будет ожидать результата AJAX-запроса по поиску всех писем, удовлетворяющим некоему критерию. Важно помнить, что «асинхронный» еще не значит «мгновенный».</p><p>Для улучшения быстродействия, важно оптимизировать результаты AJAX-запроса. Самое главное: вы должны сделать результаты AJAX-запроса кэшируемыми, что обсуждалось в <a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#expires">третьем правиле</a> про HTTP-заголовок Expires. Некоторые из правил также работают с AJAX:</p><ul><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#gzip">Правило 4: сжимайте компоненты страницы</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#dns-req">Правило 9: уменьшайте количество DNS-запросов</a></li><li><a href="./Способы ускорения загрузки вашего сайта   webo.in_files/Способы ускорения загрузки вашего сайта   webo.in.htm">Правило 10: минимизируйте Javascript</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#redirects">Правило 11: избегайте редиректов</a></li><li><a href="http://webo.in/articles/habrahabr/15-yahoo-best-practices/#etags">Правило 13: настройте ETag'и</a></li></ul><p>Хотя вообще-то третье правило наиболее важно для уменьшения времени отклика. Взглянем на пример. Почтовый веб-клиент может использовать AJAX для загрузки адресной книги пользователя, чтобы обеспечивать автодополнение. Если адресная книга не изменялась с момента последнего визита пользователя, то в этом случае она возьмется из кэша, если заголовок Expires для нее установлен в будущее. Браузер должен быть информирован о том, нужно ли загружать новую версию или можно пользоваться версией из кэша. Этого можно добиться, например, добавляя timestamp времени последней модификации адресной книги в URL AJAX-запроса, хотя бы вот так: <code>&amp;t=1190241612</code>. Если адресная книга не менялась со времени последнего визита пользователя на страницу, timestamp будет тот же и браузер использует версию книги из кэша, не делая ненужного HTTP-запроса. Если же пользователь изменял книгу, то timestamp будет другим и браузер сделает запрос на сервер, чтобы взять оттуда новую версию.</p><p>И хотя ответы на AJAX-запросы создаются динамически и могут подходить только для одного пользователя, они все равно могут быть кэшированы. Используя кэширование, ваши AJAX-приложения работают быстрее.</p><h3>Читать дальше</h3><ul><li><a href="http://webo.in/articles/habrahabr/03-presentation-layer-performance-tuning/">Оптимизируем загрузку веб-страницы</a></li><li><a href="http://webo.in/articles/habrahabr/08-all-about-css-sprites/">CSS Sprites: все, что вы знали, но боялись спросить</a></li><li><a href="http://webo.in/articles/habrahabr/13-cpu-intensive-javascript/">Оптимизируем «тяжелые» JavaScript-вычисления</a></li><li><a href="http://webo.in/articles/habrahabr/16-optimization-page-load-time/">Анализируем загрузку веб-страницы</a></li></ul><p><em><a href="http://www.habrahabr.ru/blogs/client_side_optimization/33267/#comments" rel="nofollow">Все комментарии (habrahabr.ru)</a></em></p></div></div></div></div><div class="wi-footer"><div class="wi-restrictor"><div class="wi-block-3col wi-block-first"><p class="wi-footer-copyrights"><a href="http://webo.in/"><img class="wi-footer-logo" src="./Способы ускорения загрузки вашего сайта   webo.in_files/0.gif" alt="WEBO Software" title="WEBO Software" width="63" height="25"></a> © 2011 ООО ВЕБО</p><p class="wi-footer-addresses"><span class="wi-address-type">E-mail:</span> <a href="mailto:info@webo.name">info@webo.name</a><br><span class="wi-address-type">Skype:</span> <a href="skype:nikolay.matsievsky">nikolay.matsievsky</a><br><span class="wi-address-type">Блог:</span> <a href="http://blog.webogroup.com/">blog.webogroup.com</a><br><span class="wi-address-type">Twitter:</span> <a href="http://twitter.com/wboptimizer" rel="nofollow">wboptimizer</a></p></div><div class="wi-block-3col"><h3 class="wi-footer-block-title">Продукты</h3><ul class="wi-footer-block-links"><li><a href="http://www.webogroup.com/ru/home/site-speedup/">WEBO Site SpeedUp</a></li><li><a href="http://webopulsar.ru/">WEBO Pulsar</a></li><li><a href="http://www.webogroup.com/ru/enterprise/speedometer/">WEBO Enterprise SpeedoMeter</a></li></ul></div><div class="wi-block-3col"><h3 class="wi-footer-block-title">Информация</h3><ul class="wi-footer-block-links"><li><a href="http://www.webogroup.com/ru/about/">О компании</a></li><li><a href="http://www.webogroup.com/ru/about/careers/">Вакансии</a></li><li><a href="http://www.webogroup.com/ru/about/contacts/">Контакты</a></li><li><a href="http://webo.in/sitemap/">Карта сайта</a></li></ul></div></div><span class="wi-teeth"></span></div><script type="text/javascript" async="" src="./Способы ускорения загрузки вашего сайта   webo.in_files/ga.js"></script><script type="text/javascript">var _gaq=_gaq||[];_gaq.push(['_setAccount','UA-183460-6']);_gaq.push(['_trackPageview']);(function(){var ga=document.createElement('script');ga.type='text/javascript';ga.async=true;ga.src=('https:'==document.location.protocol?'https://ssl':'http://www')+'.google-analytics.com/ga.js';var s=document.getElementsByTagName('script')[0];s.parentNode.insertBefore(ga,s);})();</script></body></html>